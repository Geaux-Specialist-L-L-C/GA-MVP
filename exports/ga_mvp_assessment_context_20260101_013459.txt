GA-MVP Assessment Context Export
Generated: 2026-01-01T01:34:59.179629
Repo root: /home/evopimp/Geaux-Dev/GA-MVP

Focus: Parent -> Add Student -> Student Learning Style Assessment -> Backend (Vertex) wiring

---- FILTERED TREE (relevant areas) ----
- src/pages/profile/ParentProfile/CreateStudent.tsx
- src/pages/profile/ParentProfile/ParentDashboard.tsx
- src/pages/profile/ParentProfile/ParentProfile.tsx
- src/pages/profile/ParentProfile/ParentProfileForm.tsx
- src/pages/profile/ParentProfile/components/StudentProgressTracker.tsx
- src/pages/profile/ParentProfile/dashboard/components/CurriculumApproval.tsx
- src/pages/profile/ParentProfile/dashboard/components/NotificationCenter.tsx
- src/pages/profile/StudentProfile/StudentDashboard.tsx
- src/pages/profile/StudentProfile/StudentProfile.tsx
- src/pages/profile/StudentProfile/StudentProfileForm.tsx
- src/components/chat/ChatUI.css
- src/components/chat/ChatUI.tsx
- src/components/chat/LearningStyleChat.tsx
- src/components/chat/TestChat.tsx
- src/components/VARKAssessment/ChatContainer.tsx
- src/components/VARKAssessment/ChatInput.tsx
- src/components/VARKAssessment/ChatMessage.tsx
- src/components/VARKAssessment/TypingIndicator.tsx
- src/components/VARKAssessment/VARKResults.tsx
- src/contexts/AuthContext.tsx
- src/contexts/ProfileContext.tsx
- src/services/__tests__/websocketService.reconnect.test.ts
- src/services/__tests__/websocketService.test.ts
- src/services/agentService.ts
- src/services/api.js
- src/services/auth-service.ts
- src/services/cheshireService.ts
- src/services/dataService.ts
- src/services/firebaseService.ts
- src/services/firestore.ts
- src/services/mongoService.ts
- src/services/mongodbService.ts
- src/services/openai.js
- src/services/profileService.ts
- src/services/userService.ts
- src/services/varkService.ts
- src/services/websocketService.ts
- src/config/dbConfig.ts
- src/config/env.js
- src/config/firebase.ts
- src/firebase/auth-service-worker.ts
- src/firebase/auth-service.ts
- src/firebase/firebase-messaging-sw.ts
- src/firebase/messaging-utils.ts
- src/types/auth.ts
- src/types/css.d.ts
- src/types/dashboard.ts
- src/types/firebase.d.ts
- src/types/profiles.ts
- src/types/service-worker.d.ts
- src/types/student.ts
- src/types/styled.d.ts
- src/types/task.ts
- src/types/types.ts
- src/types/userTypes.ts
- src/models/Assessment.ts
- src/models/LearningPlan.ts
- src/models/Parent.ts
- src/models/Student.ts
- src/models/User.ts
- src/components/common/Button.tsx
- src/components/common/Card.tsx
- src/components/common/ConnectionStatus.tsx
- src/components/common/Input.tsx
- src/components/common/LoadingSpinner.tsx
- src/components/common/Modal.tsx
- src/components/common/StyledLink.tsx
- src/components/common/Toast.tsx
- src/components/common/__tests__/ConnectionStatus.test.tsx
- src/components/common/types/index.ts

---- FILE CONTENTS ----

========================================================================================
FILE: src/App.tsx
========================================================================================
import React, { useEffect, Suspense } from 'react';
import { Routes, Route, useLocation } from 'react-router-dom';
import styled from 'styled-components';
import Layout from './components/layout/Layout';
import LoadingSpinner from './components/common/LoadingSpinner';
import PrivateRoute from './components/PrivateRoute';
import AuthRoute from './components/auth/AuthRoute';
import ErrorBoundary from './components/shared/ErrorBoundary';
import RenderDebugOverlay from './components/debug/RenderDebugOverlay';
import { useAuth } from './contexts/AuthContext';
import { auth } from './config/firebase';
import { ThemeModeProvider } from './theme/ThemeModeContext';

// Lazy load components with explicit types
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));
const Contact = React.lazy(() => import('./pages/Contact'));
const Features = React.lazy(() => import('./pages/Features'));
const Login = React.lazy(() => import('./pages/Login'));
const SignUp = React.lazy(() => import('./components/auth/SignUp'));
const LearningStyles = React.lazy(() => import('./pages/LearningStyles'));
const Curriculum = React.lazy(() => import('./pages/Curriculum'));
const ParentDashboard = React.lazy(() => import('./pages/profile/ParentProfile/ParentDashboard'));
const CreateStudent = React.lazy(() => import('./pages/profile/ParentProfile/CreateStudent'));
const StudentDashboard = React.lazy(() => import('./pages/profile/StudentProfile/StudentDashboard'));
const StudentProfile = React.lazy(() => import('./pages/profile/StudentProfile/StudentProfile'));
const LearningPlan = React.lazy(() => import('./pages/LearningPlan'));
const TakeAssessment = React.lazy(() => import('./pages/TakeAssessment'));
const LearningStyleChat = React.lazy(() => import('./components/chat/LearningStyleChat'));
const TestChat = React.lazy(() => import('./components/chat/TestChat'));
const Todos = React.lazy(() => import('./pages/Todos'));
const NotFound = React.lazy(() => import('./pages/NotFound'));

const DebugPanel: React.FC = () => {
  const { currentUser, isAuthReady } = useAuth();
  const location = useLocation();

  if (!import.meta.env.DEV) {
    return null;
  }

  return (
    <DebugPanelContainer>
      <div><strong>Auth Debug</strong></div>
      <div>isAuthReady: {String(isAuthReady)}</div>
      <div>currentUser.uid: {currentUser?.uid ?? 'null'}</div>
      <div>auth.currentUser.uid: {auth.currentUser?.uid ?? 'null'}</div>
      <div>route: {location.pathname}</div>
    </DebugPanelContainer>
  );
};

const App: React.FC = (): JSX.Element => {
  // Register service worker for Firebase messaging
  useEffect(() => {
    const registerServiceWorker = async (): Promise<void> => {
      const enableMessaging = import.meta.env.VITE_ENABLE_MESSAGING === 'true';
      if (!enableMessaging) return;
      if (!('serviceWorker' in navigator)) return;
      if (!window.isSecureContext && import.meta.env.MODE !== 'development') {
        console.debug('[sw] Skipped (insecure context outside dev)');
        return;
      }
      try {
        const qp = new URLSearchParams({
          apiKey: import.meta.env.VITE_FIREBASE_API_KEY || '',
          authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN || '',
            projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID || '',
          storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET || '',
          messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID || '',
          appId: import.meta.env.VITE_FIREBASE_APP_ID || ''
        }).toString();
        const swUrl = `/firebase-messaging-sw.js?${qp}`;
        const registration = await navigator.serviceWorker.register(swUrl, {
          scope: '/',
          type: 'module',
          updateViaCache: import.meta.env.DEV ? 'none' : 'imports'
        });
        console.debug('[sw] Registered:', registration.scope);
      } catch (error) {
        const msg = error instanceof Error ? error.message : 'Unknown error';
        (import.meta.env.PROD ? console.error : console.warn)('[sw] Registration failed:', msg);
      }
    };
    registerServiceWorker();
  }, []);
  
  return (
    <ErrorBoundary>
      <ThemeModeProvider>
        <AppContainer>
          <Suspense fallback={<LoadingSpinner />}>
            <Routes>
              <Route element={<Layout />}>
                {/* Public Routes */}
                <Route path="/" element={<Home />} />
                <Route path="/about" element={<About />} />
                <Route path="/contact" element={<Contact />} />
                <Route path="/features" element={<Features />} />
                <Route path="/login" element={<AuthRoute><Login /></AuthRoute>} />
                <Route path="/signup" element={<AuthRoute><SignUp /></AuthRoute>} />
                <Route path="/learning-styles" element={<LearningStyles />} />
                <Route path="/curriculum" element={<Curriculum />} />
                <Route path="/todos" element={<Todos />} />
                
                {/* Protected Routes */}
                <Route path="/dashboard" element={<PrivateRoute><ParentDashboard /></PrivateRoute>} />
                <Route path="/parent-dashboard" element={<PrivateRoute><ParentDashboard /></PrivateRoute>} />
                <Route path="/create-student" element={<PrivateRoute><CreateStudent /></PrivateRoute>} />
                <Route path="/student-dashboard/:id" element={<PrivateRoute><StudentDashboard /></PrivateRoute>} />
                <Route path="/student-profile/:id" element={<PrivateRoute><StudentProfile /></PrivateRoute>} />
                <Route path="/learning-plan" element={<PrivateRoute><LearningPlan /></PrivateRoute>} />
                <Route path="/assessment/:studentId" element={<PrivateRoute><TakeAssessment /></PrivateRoute>} />
                <Route path="/learning-style-chat/:studentId" element={<PrivateRoute><LearningStyleChat /></PrivateRoute>} />
                <Route path="/test-chat" element={<PrivateRoute><TestChat /></PrivateRoute>} />
                <Route path="*" element={<NotFound />} />
              </Route>
            </Routes>
          </Suspense>
          <RenderDebugOverlay />
          <DebugPanel />
        </AppContainer>
      </ThemeModeProvider>
    </ErrorBoundary>
  );
};

const AppContainer = styled.div`
  min-height: 100vh;
  background-color: ${({ theme }) => theme.palette.background.default};
`;

const DebugPanelContainer = styled.div`
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 9999;
  padding: 10px 12px;
  background: rgba(0, 0, 0, 0.75);
  color: #fff;
  font-size: 12px;
  line-height: 1.4;
  border-radius: 8px;
  pointer-events: none;
  max-width: 240px;
  word-break: break-word;
`;

export default App;

========================================================================================
FILE: src/main.tsx
========================================================================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { ProfileProvider } from './contexts/ProfileContext';
import App from './App';
import ErrorBoundary from './components/shared/ErrorBoundary';
import './index.css';
import './styles/global.css';
// Firebase app initialized centrally in config/firebase.ts (tree-shaken singletons)
import './config/firebase';

if (import.meta.env.DEV) {
  const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
  if (cspMeta) {
    cspMeta.remove();
    console.info('[CSP] Removed Content-Security-Policy meta tag in DEV for HMR.');
  }

  const metas = [
    'Cross-Origin-Embedder-Policy',
    'Cross-Origin-Opener-Policy',
    'Cross-Origin-Resource-Policy'
  ];
  metas.forEach((name) => {
    const el = document.querySelector(`meta[http-equiv="${name}"]`);
    if (el) {
      el.remove();
      console.warn(`[DEV] Removed ${name} meta tag for Firebase auth compatibility.`);
    }
  });
}

// Configure future flags for React Router v7
const future = {
  v7_startTransition: true,
  v7_relativeSplatPath: true
};

const router = createBrowserRouter([
  {
    path: "/*",
    element: (
      <ErrorBoundary>
        <AuthProvider>
          <ProfileProvider>
            <App />
          </ProfileProvider>
        </AuthProvider>
      </ErrorBoundary>
    ),
  }
], {
  future
});

// Listen for auth service worker status events
window.addEventListener('firebase-auth-worker-status', (event: Event) => {
  const { success, isSecure, error } = (event as CustomEvent).detail;
  if (!success) {
    console.warn(
      'Auth service worker initialization status:', 
      { success, isSecure, error }
    );
  }
});

// Listen for auth errors from service worker
window.addEventListener('firebase-auth-error', (event: Event) => {
  const { error, fallbackToRedirect } = (event as CustomEvent).detail;
  console.error('Firebase auth error:', error);
  if (fallbackToRedirect) {
    console.info('Falling back to redirect method for authentication');
  }
});

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);

========================================================================================
FILE: src/index.tsx
========================================================================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { ProfileProvider } from './contexts/ProfileContext';
import App from './App';
import ErrorBoundary from './components/shared/ErrorBoundary';
import './index.css';

// Listen for auth service worker status events
window.addEventListener('firebase-auth-worker-status', (event: Event) => {
  const { success, isSecure, error } = (event as CustomEvent).detail;
  if (!success) {
    console.warn(
      'Auth service worker initialization status:', 
      { success, isSecure, error }
    );
  }
});

// Listen for auth errors from service worker
window.addEventListener('firebase-auth-error', (event: Event) => {
  const { error, fallbackToRedirect } = (event as CustomEvent).detail;
  console.error('Firebase auth error:', error);
  if (fallbackToRedirect) {
    console.info('Falling back to redirect method for authentication');
  }
});

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <ErrorBoundary>
      <BrowserRouter>
        <AuthProvider>
          <ProfileProvider>
            <App />
          </ProfileProvider>
        </AuthProvider>
      </BrowserRouter>
    </ErrorBoundary>
  </React.StrictMode>
);

========================================================================================
FILE: src/components/PrivateRoute.tsx
========================================================================================
// File: /src/components/PrivateRoute.tsx
// Description: A route component that protects routes from unauthorized access
// Author: GitHub Copilot

import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import LoadingSpinner from './common/LoadingSpinner';
import styled from 'styled-components';

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: rgba(255, 255, 255, 0.8);
`;

interface PrivateRouteProps {
  children: React.ReactNode;
}

const PrivateRoute: React.FC<PrivateRouteProps> = ({ children }): JSX.Element => {
  const { currentUser, isAuthReady } = useAuth();
  const location = useLocation();

  // Show loading spinner while auth state is being determined
  if (!isAuthReady) {
    if (import.meta.env.DEV) {
      console.debug('[PrivateRoute] auth ready:', isAuthReady, 'authed:', !!currentUser);
    }
    return (
      <LoadingContainer>
        <LoadingSpinner />
        <span>Loading…</span>
      </LoadingContainer>
    );
  }

  // If not authenticated, redirect to login with current location
  if (!currentUser) {
    const from = `${location.pathname}${location.search || ''}${location.hash || ''}`;
    return (
      <Navigate 
        to="/login" 
        state={{ 
          from
        }} 
        replace 
      />
    );
  }

  // If authenticated, render the protected route
  if (import.meta.env.DEV) {
    console.debug('[PrivateRoute] auth ready:', isAuthReady, 'authed:', !!currentUser);
  }

  return <>{children}</>;
};

export default PrivateRoute;

========================================================================================
FILE: src/components/auth/AuthRoute.tsx
========================================================================================
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';
import LoadingSpinner from '../common/LoadingSpinner';
import styled from 'styled-components';

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: rgba(255, 255, 255, 0.8);
`;

interface AuthRouteProps {
  children: React.ReactNode;
}

const AuthRoute: React.FC<AuthRouteProps> = ({ children }) => {
  const { currentUser, isAuthReady } = useAuth();
  const location = useLocation();

  if (!isAuthReady) {
    if (import.meta.env.DEV) {
      console.debug('[AuthRoute] auth ready:', isAuthReady, 'authed:', !!currentUser);
    }
    return (
      <LoadingContainer>
        <LoadingSpinner />
      </LoadingContainer>
    );
  }

  // If user is authenticated and tries to access auth pages, redirect to dashboard
  if (currentUser) {
    const from = (location.state as { from?: string } | null)?.from || '/dashboard';
    return <Navigate to={from} replace />;
  }

  if (import.meta.env.DEV) {
    console.debug('[AuthRoute] auth ready:', isAuthReady, 'authed:', !!currentUser);
  }

  // Allow access to auth pages if not authenticated
  return <>{children}</>;
};

export default AuthRoute;

========================================================================================
FILE: src/components/auth/LoginForm.tsx
========================================================================================
import React, { useState, useEffect } from 'react';
import styled from 'styled-components';
import { useAuth } from '../../contexts/AuthContext';
import { auth } from '../../config/firebase';
import GoogleLoginButton from '../GoogleLoginButton';
import Button from '../common/Button';
import FormGroup from '../molecules/FormGroup';
import './auth.css';

const ErrorMessage = styled.div`
  color: #dc3545;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 4px;
  padding: 10px;
  margin: 10px 0;
  font-size: 0.9rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0 5px;
  color: #dc3545;
  &:hover {
    opacity: 0.7;
  }
`;

const Form = styled.form`
  display: flex;
  flex-direction: column;
  gap: 1rem;
  width: 100%;
  max-width: 400px;
`;

const SigningInMessage = styled.div`
  font-size: 0.9rem;
  color: var(--text-color);
  display: flex;
  align-items: center;
  gap: 0.5rem;
`;

const Input = styled.input`
  padding: 0.75rem;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  font-size: 1rem;
  &:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(70, 84, 246, 0.2);
  }
`;

const LoginForm: React.FC = (): JSX.Element => {
  const { login, loginWithGoogle, loading: authLoading, error: authError, clearError } = useAuth();
  const [email, setEmail] = useState<string>('');
  const [password, setPassword] = useState<string>('');
  const [localError, setLocalError] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const isDev = import.meta.env.DEV;

  useEffect(() => {
    if (typeof clearError === 'function') {
      clearError();
    }
  }, [clearError]);

  const handleDismissError = () => {
    setLocalError('');
    if (typeof clearError === 'function') {
      clearError();
    }
  };

  const handleLogin = async (): Promise<void> => {
    try {
      setLocalError('');
      setLoading(true);
      if (isDev) {
        console.debug('[LoginForm] submit start', email);
      }
      await login(email, password);
      if (isDev) {
        console.debug('[LoginForm] login() resolved', auth.currentUser?.uid ?? null);
      }
    } catch (err) {
      setLocalError(err instanceof Error ? err.message : 'Failed to log in');
      console.error('Login error:', err);
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleLogin = async (): Promise<void> => {
    try {
      setLocalError('');
      setLoading(true);
      if (isDev) {
        console.debug('[LoginForm] google submit start', email);
      }
      await loginWithGoogle();
      if (isDev) {
        console.debug('[LoginForm] google login() resolved', auth.currentUser?.uid ?? null);
      }
    } catch (err) {
      setLocalError(err instanceof Error ? err.message : 'Failed to sign in');
      console.error('Login error:', err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Form onSubmit={(e) => {
      e.preventDefault();
      handleLogin();
    }}>
      {(localError || authError) && (
        <ErrorMessage role="alert">
          <span>{localError || authError}</span>
          <CloseButton
            type="button"
            aria-label="Dismiss error"
            onClick={handleDismissError}
          >
            ×
          </CloseButton>
        </ErrorMessage>
      )}
      <FormGroup
        label="Email"
        inputs={[{
          placeholder: 'Enter your email',
          value: email,
          onChange: (e) => setEmail(e.target.value),
          error: false
        }]}
      />
      <FormGroup
        label="Password"
        inputs={[{
          placeholder: 'Enter your password',
          value: password,
          onChange: (e) => setPassword(e.target.value),
          error: false
        }]}
      />
      <Button type="submit" $variant="primary" disabled={loading || authLoading}>
        {loading || authLoading ? 'Signing in…' : 'Login'}
      </Button>
      {(loading || authLoading) && (
        <SigningInMessage>
          <span aria-hidden="true">⏳</span>
          Signing in…
        </SigningInMessage>
      )}
      <GoogleLoginButton
        handleGoogleLogin={handleGoogleLogin}
        loading={loading || authLoading}
        error={localError || authError || undefined}
        onDismissError={handleDismissError}
      />
    </Form>
  );
};

export default LoginForm;

========================================================================================
FILE: src/components/auth/SignUp.tsx
========================================================================================
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import styled from 'styled-components';
import { FcGoogle } from 'react-icons/fc';
import { useAuth } from '../../contexts/AuthContext';
import { CheshireService } from '../../services/cheshireService';
import Button from '../common/Button';
import FormGroup from '../molecules/FormGroup';

interface FormData {
  email: string;
  password: string;
  confirmPassword: string;
}

const SignUp: React.FC = () => {
  const [formData, setFormData] = useState<FormData>({
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>('');
  const { signup, loginWithGoogle } = useAuth();
  const navigate = useNavigate();

  const createCheshireAccount = async (uid: string, email: string) => {
    try {
      await CheshireService.createCheshireUser(uid, email);
    } catch (error) {
      console.error('Error creating Cheshire account:', error);
      throw new Error('Failed to create Cheshire account');
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    
    if (formData.password !== formData.confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    try {
      setLoading(true);
      const userCredential = await signup(formData.email, formData.password);
      
      if (userCredential?.user) {
        await createCheshireAccount(userCredential.user.uid, userCredential.user.email || '');
      }
      
      navigate('/dashboard');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create account');
      console.error('Signup error:', err);
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleSignup = async () => {
    try {
      setLoading(true);
      setError('');
      await loginWithGoogle();
      navigate('/dashboard');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to sign up with Google');
      console.error('Google signup error:', err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <SignUpContainer>
      <SignUpCard className="glass-card">
        <Header>
          <span className="badge">Create account</span>
          <h2>Join the Geaux Academy learning lab.</h2>
          <p>Start with an assessment and build a learning path that fits you.</p>
        </Header>
        {error && (
          <ErrorMessage>
            <span>{error}</span>
            <DismissButton onClick={() => setError('')}>✕</DismissButton>
          </ErrorMessage>
        )}
        
        <Form onSubmit={handleSubmit}>
          <FormGroup
            label="Email"
            inputs={[{
              placeholder: 'Enter your email',
              value: formData.email,
              onChange: (e) => setFormData({ ...formData, email: e.target.value }),
              error: false
            }]}
          />
          <FormGroup
            label="Password"
            inputs={[{
              placeholder: 'Enter your password',
              value: formData.password,
              onChange: (e) => setFormData({ ...formData, password: e.target.value }),
              error: false
            }]}
          />
          <FormGroup
            label="Confirm Password"
            inputs={[{
              placeholder: 'Confirm your password',
              value: formData.confirmPassword,
              onChange: (e) => setFormData({ ...formData, confirmPassword: e.target.value }),
              error: false
            }]}
          />
          <Button type="submit" $variant="primary">
            {loading ? 'Creating Account...' : 'Sign Up'}
          </Button>
        </Form>

        <Divider>
          <span>Or</span>
        </Divider>

        <GoogleButton onClick={handleGoogleSignup} disabled={loading}>
          <FcGoogle />
          <span>Sign up with Google</span>
        </GoogleButton>

        <LoginPrompt>
          Already have an account? <Link to="/login">Log In</Link>
        </LoginPrompt>
      </SignUpCard>
    </SignUpContainer>
  );
};

const SignUpContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 80px);
  padding: 1rem;
  background-color: var(--background-color);
`;

const SignUpCard = styled.div`
  background: rgba(255, 255, 255, 0.9);
  padding: 2rem;
  border-radius: 16px;
  border: 1px solid var(--border-color);
  width: 100%;
  max-width: 460px;
`;

const Header = styled.div`
  display: grid;
  gap: 0.75rem;
  margin-bottom: 1.5rem;

  p {
    color: var(--text-secondary);
  }
`;

const Form = styled.form`
  display: flex;
  flex-direction: column;
  gap: 1rem;
`;

const Divider = styled.div`
  display: flex;
  align-items: center;
  text-align: center;
  margin: 1.5rem 0;

  &::before,
  &::after {
    content: '';
    flex: 1;
    border-bottom: 1px solid #ddd;
  }

  span {
    padding: 0 0.5rem;
    color: #666;
    font-size: 0.875rem;
  }
`;

const GoogleButton = styled.button`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  padding: 0.75rem;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  background: white;
  cursor: pointer;
  transition: background-color 0.2s;

  &:hover {
    background-color: #f8f8f8;
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }
`;

const LoginPrompt = styled.p`
  text-align: center;
  margin-top: 1.5rem;
  font-size: 0.875rem;
  color: var(--text-color);
`;

const Link = styled.a`
  color: var(--primary-color);
  text-decoration: none;
  font-weight: 500;

  &:hover {
    text-decoration: underline;
  }
`;

const ErrorMessage = styled.div`
  color: #dc2626;
  background-color: #fee2e2;
  padding: 0.75rem;
  border-radius: 4px;
  margin-bottom: 1rem;
  font-size: 0.875rem;
`;

const DismissButton = styled.button`
  background: none;
  border: none;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0 5px;
  color: #dc2626;
  &:hover {
    opacity: 0.7;
  }
`;

export default SignUp;

========================================================================================
FILE: src/contexts/AuthContext.tsx
========================================================================================
import React, { createContext, useContext, useEffect, useRef, useState } from 'react';
import {
  createUserWithEmailAndPassword,
  getRedirectResult,
  onAuthStateChanged,
  signInWithEmailAndPassword,
  User,
  UserCredential
} from 'firebase/auth';
import { auth, authInit } from '../config/firebase';
import { firebaseService } from '../services/firebaseService';
import type { AuthContextType } from '../types/auth';

export type AuthContextProps = AuthContextType;

export const AuthContext = createContext<AuthContextProps>({
  currentUser: null,
  user: null,
  loading: true,
  isLoading: true,
  isAuthReady: false,
  error: null,
  login: async () => {
    throw new Error('AuthProvider not initialized');
  },
  loginWithGoogle: async () => {
    throw new Error('AuthProvider not initialized');
  },
  signup: async () => {
    throw new Error('AuthProvider not initialized');
  },
  logout: async () => {
    throw new Error('AuthProvider not initialized');
  },
  clearError: () => undefined
});

export const useAuth = () => useContext(AuthContext);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const redirectHandledRef = useRef(false);
  const isDev = import.meta.env.DEV;

  useEffect(() => {
    if (isDev) {
      console.debug('[AuthProvider] mount');
    }
    return () => {
      if (isDev) {
        console.debug('[AuthProvider] unmount');
      }
    };
  }, [isDev]);

  useEffect(() => {
    let isMounted = true;
    let unsubscribe = () => undefined;
    let hasResolved = false;
    let authReadyTimeout: ReturnType<typeof setTimeout> | null = null;

    const initAuth = () => {
      if (isDev) {
        console.debug('[AuthProvider] starting authInit');
      }
      // Do not block auth readiness on persistence; Firebase can still report auth state.
      void authInit.catch((authError) => {
        console.warn('[AuthProvider] authInit failed (continuing):', authError);
      });

      if (!isMounted) return;
      if (isDev) {
        console.debug('[AuthProvider] subscribing onAuthStateChanged');
      }
      unsubscribe = onAuthStateChanged(
        auth,
        (user) => {
          console.log('[AuthProvider] onAuthStateChanged fired uid=', user?.uid ?? null);
          if (isDev) {
            console.debug('[AuthProvider] onAuthStateChanged', {
              userUid: user?.uid ?? null,
              currentUserUid: auth.currentUser?.uid ?? null,
              persistenceManager: (auth as { persistenceManager?: unknown }).persistenceManager
            });
          }
          setCurrentUser(user);
          setError(null);
          if (!hasResolved) {
            hasResolved = true;
            setLoading(false);
            setIsAuthReady(true);
            if (authReadyTimeout) {
              clearTimeout(authReadyTimeout);
              authReadyTimeout = null;
            }
          }
        },
        (authError) => {
          console.error('Auth state change error:', authError);
          setError(authError instanceof Error ? authError.message : 'Failed to determine auth state');
          if (!hasResolved) {
            hasResolved = true;
            setLoading(false);
            setIsAuthReady(true);
            if (authReadyTimeout) {
              clearTimeout(authReadyTimeout);
              authReadyTimeout = null;
            }
          }
        }
      );

      authReadyTimeout = setTimeout(() => {
        if (!hasResolved) {
          console.error('[AuthProvider] auth readiness timeout: forcing ready state');
          hasResolved = true;
          setIsAuthReady(true);
          setLoading(false);
        }
      }, 2000);
    };

    initAuth();

    return () => {
      isMounted = false;
      unsubscribe();
      if (authReadyTimeout) {
        clearTimeout(authReadyTimeout);
      }
    };
  }, [isDev]);

  useEffect(() => {
    if (redirectHandledRef.current) {
      return;
    }
    redirectHandledRef.current = true;

    const resolveRedirect = async () => {
      try {
        const result = await getRedirectResult(auth);
        console.log('getRedirectResult result=', result);
      } catch (redirectError) {
        console.error('getRedirectResult error:', redirectError);
        setError(
          redirectError instanceof Error
            ? redirectError.message
            : 'Failed to complete redirect sign-in'
        );
      }
    };

    resolveRedirect();
  }, []);

  useEffect(() => {
    console.info('[AuthProvider] active auth uid', currentUser?.uid ?? null);
  }, [currentUser]);

  const clearError = () => setError(null);

  const isPopupCancelled = (authError: unknown): boolean => {
    const firebaseError = authError as { code?: string };
    return firebaseError.code === 'auth/popup-closed-by-user';
  };

  const runWithAuthState = async <T,>(
    action: () => Promise<T>,
    fallbackMessage: string
  ): Promise<T> => {
    setLoading(true);
    setError(null);
    try {
      return await action();
    } catch (authError) {
      if (isPopupCancelled(authError)) {
        return null as T;
      }
      const message =
        authError instanceof Error ? authError.message : fallbackMessage;
      setError(message);
      throw authError instanceof Error ? authError : new Error(message);
    } finally {
      setLoading(false);
    }
  };

  const login = (email: string, password: string): Promise<UserCredential> =>
    runWithAuthState(async () => {
      const credential = await signInWithEmailAndPassword(auth, email, password);
      setCurrentUser(credential.user);
      return credential;
    }, 'Failed to log in');

  const signup = (email: string, password: string): Promise<UserCredential> =>
    runWithAuthState(async () => {
      const credential = await createUserWithEmailAndPassword(auth, email, password);
      setCurrentUser(credential.user);
      return credential;
    }, 'Failed to sign up');

  const loginWithGoogle = (): Promise<User | null> =>
    runWithAuthState(async () => {
      const user = await firebaseService.signInWithGoogle();
      if (user) {
        setCurrentUser(user);
      }
      return user;
    }, 'Failed to sign in with Google');

  const logout = (): Promise<void> =>
    runWithAuthState(async () => {
      await firebaseService.signOut();
    }, 'Failed to log out');

  return (
    <AuthContext.Provider
      value={{
        currentUser,
        user: currentUser,
        loading,
        isLoading: loading,
        isAuthReady,
        error,
        login,
        loginWithGoogle,
        signup,
        logout,
        clearError
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export default AuthProvider;

========================================================================================
FILE: src/contexts/ProfileContext.tsx
========================================================================================
import React, { createContext, useContext, useState, ReactNode, useEffect } from 'react';
import { mongoService } from '../services/mongoService';
import { useAuth } from './AuthContext';

interface Profile {
  id?: string;
  name?: string;
  email?: string;
  role?: string;
  learningStyle?: string;
  grade?: string;
}

interface ProfileContextType {
  profile: Profile | null;
  updateProfile: (newProfile: Profile) => void;
}

const ProfileContext = createContext<ProfileContextType | undefined>(undefined);

export const useProfile = (): ProfileContextType => {
  const context = useContext(ProfileContext);
  if (!context) {
    throw new Error('useProfile must be used within a ProfileProvider');
  }
  return context;
};

interface ProfileProviderProps {
  children: ReactNode;
}

export const ProfileProvider: React.FC<ProfileProviderProps> = ({ children }) => {
  const { currentUser } = useAuth();
  const [profile, setProfile] = useState<Profile | null>(null);

  useEffect(() => {
    const fetchProfile = async () => {
      if (currentUser) {
        const userProfile = await mongoService.getUserProfile(currentUser.uid);
        setProfile(userProfile);
      }
    };

    fetchProfile();
  }, [currentUser]);

  const updateProfile = async (newProfile: Profile) => {
    if (currentUser) {
      const updatedProfile = await mongoService.updateUserProfile(currentUser.uid, newProfile);
      setProfile(updatedProfile);
    }
  };

  return (
    <ProfileContext.Provider value={{ profile, updateProfile }}>
      {children}
    </ProfileContext.Provider>
  );
};

========================================================================================
FILE: src/pages/profile/ParentProfile/ParentDashboard.tsx
========================================================================================
import React, { useState, useEffect } from 'react';
import StudentProgressTracker from './components/StudentProgressTracker';
import NotificationCenter from './dashboard/components/NotificationCenter';
import LearningStyleInsights from '../components/LearningStyleInsights';
import CurriculumApproval from './dashboard/components/CurriculumApproval';
import styled from 'styled-components';
import { useAuth } from "../../../contexts/AuthContext";
import { getParentProfile, getStudentsByIds } from '../../../services/profileService';
import { Parent } from '../../../types/auth';
import { Student as StudentProfile } from '../../../types/profiles';
import { useNavigate } from 'react-router-dom';

interface ParentProfile extends Omit<Parent, 'students'> {
  name: string;
  students: StudentProfile[];
  createdAt: string;
  updatedAt: string;
}

const ParentDashboard: React.FC = () => {
  const [activeTab, setActiveTab] = useState<'overview' | 'progress' | 'curriculum' | 'insights'>('overview');
  const [parentProfile, setParentProfile] = useState<ParentProfile | null>(null);
  const [selectedStudent, setSelectedStudent] = useState<string | null>(null);
  const { currentUser: user, loginWithGoogle } = useAuth();
  const [error, setError] = useState<string>("");
  const [studentsLoading, setStudentsLoading] = useState(false);
  const [studentsError, setStudentsError] = useState<string>('');
  const navigate = useNavigate();

  useEffect(() => {
    const fetchProfile = async () => {
      if (user) {
        setStudentsLoading(true);
        setStudentsError('');
        try {
          const profile = await getParentProfile(user.uid);
          if (profile) {
            const students = await getStudentsByIds(profile.students || []);
            setParentProfile({
              ...profile,
              name: profile.displayName,
              id: profile.id || user.uid,
              students: students || [],
              createdAt: profile.createdAt || new Date().toISOString(),
              updatedAt: profile.updatedAt || new Date().toISOString()
            });
          }
        } catch (error) {
          console.error("Error fetching profile:", error);
          setStudentsError('Unable to load student profiles. Please try again.');
        } finally {
          setStudentsLoading(false);
        }
      }
    };
    fetchProfile();
  }, [user]);

  const handleGoogleLogin = async () => {
    try {
      setError("");
      await loginWithGoogle();
    } catch (error) {
      setError("Login failed. Please try again.");
      console.error("Login error:", error);
    }
  };

  const handleProfileSwitch = (studentId: string) => {
    setSelectedStudent(studentId);
    navigate(`/student-dashboard/${studentId}`);
  };

  return (
    <DashboardContainer>
      <DashboardHeader>
        <h1>Parent Dashboard</h1>
      </DashboardHeader>

      <ProfileSection>
        <h2>Account Details</h2>
        <p>Name: {parentProfile?.name || "Parent"}</p>
        <p>Email: {user?.email}</p>
        {!user && (
          <GoogleButton onClick={handleGoogleLogin}>
            Sign in with Google
          </GoogleButton>
        )}
      </ProfileSection>

      {user && (
        <>
          <StudentManagement>
            <h2>Student Profiles</h2>
            <AddStudentButton onClick={() => navigate('/create-student')}>➕ Add Student</AddStudentButton>
            
            <StudentList>
              {studentsLoading && <StatusMessage>Loading student profiles...</StatusMessage>}
              {!studentsLoading && studentsError && (
                <StatusMessage role="alert">{studentsError}</StatusMessage>
              )}
              {!studentsLoading && !studentsError && parentProfile?.students?.length === 0 && (
                <StatusMessage>No students yet. Add your first student to get started.</StatusMessage>
              )}
              {!studentsLoading && !studentsError && parentProfile?.students?.map((student) => (
                <StudentCard key={student.id} onClick={() => handleProfileSwitch(student.id)}>
                  <h3>{student.name}</h3>
                  <p>Grade: {student.grade}</p>
                  <p>Assessment: {student.hasTakenAssessment ? 'Completed' : 'Pending'}</p>
                  <ViewProfileButton>View Profile</ViewProfileButton>
                </StudentCard>
              ))}
            </StudentList>
          </StudentManagement>

          <TabContainer>
            <TabList>
              <Tab active={activeTab === 'overview'} onClick={() => setActiveTab('overview')}>Overview</Tab>
              <Tab active={activeTab === 'progress'} onClick={() => setActiveTab('progress')}>Progress</Tab>
              <Tab active={activeTab === 'curriculum'} onClick={() => setActiveTab('curriculum')}>Curriculum</Tab>
              <Tab active={activeTab === 'insights'} onClick={() => setActiveTab('insights')}>Insights</Tab>
            </TabList>

            <TabContent>
              {activeTab === 'overview' && <OverviewTab />}
              {activeTab === 'progress' && <StudentProgressTracker />}
              {activeTab === 'curriculum' && <CurriculumApproval />}
              {activeTab === 'insights' && <LearningStyleInsights />}
            </TabContent>
          </TabContainer>

          <NotificationSection>
            <NotificationCenter />
          </NotificationSection>
        </>
      )}
    </DashboardContainer>
  );
};

// Styled components
const DashboardContainer = styled.div`
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
`;

const DashboardHeader = styled.div`
  margin-bottom: 2rem;
  h1 {
    font-size: 2rem;
    color: var(--primary-color);
  }
`;

const ProfileSection = styled.div`
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  margin-bottom: 2rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
`;

const StudentManagement = styled.div`
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  margin-bottom: 2rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
`;

const AddStudentButton = styled.button`
  background: var(--primary-color);
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;

  &:hover {
    background: var(--primary-dark);
  }
`;

const StudentList = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
`;

const StatusMessage = styled.div`
  grid-column: 1 / -1;
  padding: 1rem;
  border-radius: 6px;
  background: #f8fafc;
  color: #475569;
  text-align: center;
`;

const StudentCard = styled.div`
  background: #f8fafc;
  padding: 1rem;
  border-radius: 4px;
  border: 1px solid #e2e8f0;
  cursor: pointer;
`;

const TabContainer = styled.div`
  margin-top: 2rem;
`;

const TabList = styled.div`
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
`;

interface TabProps {
  active: boolean;
}

const Tab = styled.button<TabProps>`
  padding: 0.5rem 1rem;
  border: none;
  background: ${props => props.active ? 'var(--primary-color)' : 'transparent'};
  color: ${props => props.active ? 'white' : 'var(--text-color)'};
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;

  &:hover {
    background: ${props => props.active ? 'var(--primary-dark)' : '#f0f0f0'};
  }
`;

const TabContent = styled.div`
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
`;

const NotificationSection = styled.div`
  margin-top: 2rem;
`;

const GoogleButton = styled.button`
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: white;
  border: 1px solid #ddd;
  padding: 0.75rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;

  &:hover {
    background: #f8f8f8;
  }
`;

const OverviewTab = styled.div`
  // Add specific styles for the overview tab content
`;

const ViewProfileButton = styled.button`
  margin-top: 1rem;
  padding: 0.5rem 1rem;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;

  &:hover {
    background-color: var(--primary-dark);
  }
`;

export default ParentDashboard;

========================================================================================
FILE: src/pages/profile/ParentProfile/CreateStudent.tsx
========================================================================================
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import styled from 'styled-components';
import { addStudentProfile } from '../../../services/profileService';
import { useAuth } from '../../../contexts/AuthContext';

interface NewStudent {
  name: string;
  grade: string;
  hasTakenAssessment: boolean;
}

const CreateStudent: React.FC = () => {
  const [studentName, setStudentName] = useState<string>('');
  const [grade, setGrade] = useState<string>('');
  const [error, setError] = useState<string>('');
  const [loading, setLoading] = useState<boolean>(false);
  const { currentUser } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!currentUser) {
      setError('Please sign in to add a student.');
      return;
    }
    if (!studentName.trim()) {
      setError('Student name is required.');
      return;
    }
    if (!grade.trim()) {
      setError('Grade level is required.');
      return;
    }

    setLoading(true);
    setError('');

    try {
      const newStudent: NewStudent = { 
        name: studentName.trim(), 
        grade: grade.trim(), 
        hasTakenAssessment: false
      };

      await addStudentProfile(currentUser.uid, newStudent);
      setStudentName('');
      setGrade('');
      navigate('/dashboard');
    } catch (err) {
      setError('Failed to create student profile. Please try again.');
      console.error('Error creating student:', err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <FormContainer>
      <h2>Add a New Student</h2>
      {error && <ErrorMessage>{error}</ErrorMessage>}
      
      <Form onSubmit={handleSubmit}>
        <FormGroup>
          <Label>
            Student Name:
            <Input
              type="text"
              value={studentName}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => setStudentName(e.target.value)}
              placeholder="Enter student's name"
              required
            />
          </Label>
        </FormGroup>

        <FormGroup>
          <Label>
            Grade Level:
            <Select 
              value={grade} 
              onChange={(e: React.ChangeEvent<HTMLSelectElement>) => setGrade(e.target.value)}
              required
            >
              <option value="">Select Grade</option>
              <option value="K">Kindergarten</option>
              {Array.from({ length: 12 }, (_, i) => (
                <option key={i + 1} value={String(i + 1)}>
                  Grade {i + 1}
                </option>
              ))}
            </Select>
          </Label>
        </FormGroup>

        <SubmitButton type="submit" disabled={loading}>
          {loading ? 'Creating Profile...' : 'Save Profile'}
        </SubmitButton>
      </Form>
    </FormContainer>
  );
};

const FormContainer = styled.div`
  max-width: 500px;
  margin: 2rem auto;
  padding: 2rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);

  h2 {
    margin-bottom: 1.5rem;
    color: var(--primary-color);
  }
`;

const Form = styled.form`
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
`;

const FormGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
`;

const Label = styled.label`
  font-weight: 500;
  color: #333;
`;

const Input = styled.input`
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;
`;

const Select = styled.select`
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;
  background: white;
`;

const SubmitButton = styled.button`
  background: var(--primary-color);
  color: white;
  padding: 0.75rem;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }

  &:hover:not(:disabled) {
    background: var(--primary-dark);
  }
`;

const ErrorMessage = styled.div`
  color: #dc2626;
  background: #fee2e2;
  padding: 0.75rem;
  border-radius: 4px;
  margin-bottom: 1rem;
`;

export default CreateStudent;

========================================================================================
FILE: src/pages/profile/ParentProfile/ParentProfile.tsx
========================================================================================
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { addStudent } from '../../../store/slices/profileSlice';
import { RootState } from '../../../store';
import { Student } from '../../../types/auth';  // Using the auth Student type consistently
import { useAuth } from '../../../contexts/AuthContext';
import { FcGoogle } from 'react-icons/fc';
import styled from 'styled-components';
import { getStudentProfile } from '../../../services/profileService';

const ParentProfile: React.FC = () => {
  const dispatch = useDispatch();
  const parent = useSelector((state: RootState) => state.profile.parent);
  const [showAddStudent, setShowAddStudent] = useState(false);
  const [newStudent, setNewStudent] = useState<Partial<Student>>({});
  const { loginWithGoogle } = useAuth();
  const [error, setError] = useState("");
  const [studentsData, setStudentsData] = useState<Student[]>([]);

  const handleAddStudent = () => {
    if (newStudent.name) {
      dispatch(addStudent({
        id: Date.now().toString(),
        name: newStudent.name || '',
        grade: newStudent.grade || '',
        parentId: parent?.id || '',
        hasTakenAssessment: false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }));
      setShowAddStudent(false);
      setNewStudent({});
    }
  };

  const handleGoogleLogin = async () => {
    try {
      setError("");
      await loginWithGoogle();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to login");
      console.error("Login error:", err);
    }
  };

  useEffect(() => {
    const fetchStudentsData = async () => {
      if (parent?.students) {
        try {
          const studentsPromises = parent.students.map(async studentId => {
            const student = await getStudentProfile(studentId);
            return student as Student;  // Ensure type consistency
          });
          const fetchedStudents = await Promise.all(studentsPromises);
          setStudentsData(fetchedStudents.filter((s): s is Student => s !== null));
        } catch (error) {
          console.error('Error fetching students:', error);
        }
      }
    };

    fetchStudentsData();
  }, [parent?.students]);

  return (
    <Container>
      <ProfileBox>
        <Title>Parent Profile</Title>
        
        {error && <ErrorMessage>{error}</ErrorMessage>}

        <GoogleButton onClick={handleGoogleLogin}>
          <FcGoogle className="text-xl" />
          Sign in with Google
        </GoogleButton>

        <div className="students-section">
          <h3>My Students</h3>
          <button onClick={() => setShowAddStudent(true)}>Add Student</button>

          {showAddStudent && (
            <div className="add-student-form">
              <input
                type="text"
                placeholder="Student Name"
                value={newStudent.name || ''}
                onChange={(e) => setNewStudent({...newStudent, name: e.target.value})}
              />
              <input
                type="text"
                placeholder="Grade"
                value={newStudent.grade || ''}
                onChange={(e) => setNewStudent({...newStudent, grade: e.target.value})}
              />
              <button onClick={handleAddStudent}>Save</button>
              <button onClick={() => setShowAddStudent(false)}>Cancel</button>
            </div>
          )}

          <div className="students-list">
            {studentsData.map((student) => (
              <div key={student.id} className="student-card">
                <h4>{student.name}</h4>
                {student.grade && <p>Grade: {student.grade}</p>}
                <p>Learning Style: {student.learningStyle || 'Not assessed'}</p>
                <div className="progress-summary">
                  {student.hasTakenAssessment ? (
                    <div className="assessment-status">Assessment Complete</div>
                  ) : (
                    <div className="assessment-status">Assessment Needed</div>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      </ProfileBox>
    </Container>
  );
};

const Container = styled.div`
  padding: 2rem;
`;

const ProfileBox = styled.div`
  background: white;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
`;

const Title = styled.h1`
  text-align: center;
  margin-bottom: 2rem;
`;

const GoogleButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  cursor: pointer;
  margin-bottom: 2rem;

  &:hover {
    background: #f5f5f5;
  }
`;

const ErrorMessage = styled.div`
  color: #dc2626;
  background: #fee2e2;
  padding: 0.75rem;
  border-radius: 4px;
  margin-bottom: 1rem;
`;

export default ParentProfile;

========================================================================================
FILE: src/pages/profile/ParentProfile/ParentProfileForm.tsx
========================================================================================
import React, { useState } from 'react';
import { useAuth } from '../../../contexts/AuthContext';
import { createParentProfile } from '../../../services/profileService';
import styled from 'styled-components';

interface FormData {
  displayName: string;
  phone: string;
  email: string;
}

export const ParentProfileForm: React.FC = () => {
  const { currentUser } = useAuth();
  const [formData, setFormData] = useState<FormData>({
    displayName: currentUser?.displayName || '',
    phone: '',
    email: currentUser?.email || ''
  });
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>('');
  const [success, setSuccess] = useState<boolean>(false);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!currentUser) {
      setError('You must be logged in to create a profile');
      return;
    }

    setLoading(true);
    setError('');
    try {
      console.log('📝 Creating parent profile for:', currentUser.uid);
      await createParentProfile({
        uid: currentUser.uid,
        email: formData.email,
        displayName: formData.displayName,
        phone: formData.phone
      });
      setSuccess(true);
      console.log('✅ Parent profile created successfully');
    } catch (err) {
      console.error('❌ Error creating parent profile:', err);
      setError('Failed to create profile. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  if (success) {
    return (
      <SuccessMessage>
        Profile created successfully! You can now add students to your account.
      </SuccessMessage>
    );
  }

  return (
    <FormContainer>
      <h2>Complete Your Parent Profile</h2>
      {error && <ErrorMessage>{error}</ErrorMessage>}
      
      <Form onSubmit={handleSubmit}>
        <FormGroup>
          <Label htmlFor="displayName">Full Name</Label>
          <Input
            id="displayName"
            type="text"
            placeholder="Your full name"
            value={formData.displayName}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => setFormData({
              ...formData,
              displayName: e.target.value
            })}
            required
          />
        </FormGroup>

        <FormGroup>
          <Label htmlFor="phone">Phone Number</Label>
          <Input
            id="phone"
            type="tel"
            placeholder="Your phone number"
            value={formData.phone}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => setFormData({
              ...formData,
              phone: e.target.value
            })}
            required
          />
        </FormGroup>

        <FormGroup>
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            placeholder="Your email"
            value={formData.email}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => setFormData({
              ...formData,
              email: e.target.value
            })}
            required
            disabled={!!currentUser?.email}
          />
        </FormGroup>

        <SubmitButton type="submit" disabled={loading}>
          {loading ? 'Creating Profile...' : 'Create Profile'}
        </SubmitButton>
      </Form>
    </FormContainer>
  );
};

const FormContainer = styled.div`
  max-width: 500px;
  margin: 0 auto;
  padding: 2rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);

  h2 {
    margin-bottom: 1.5rem;
    color: var(--primary-color);
    text-align: center;
  }
`;

const Form = styled.form`
  display: flex;
  flex-direction: column;
  gap: 1rem;
`;

const FormGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
`;

const Label = styled.label`
  font-weight: 500;
  color: #333;
`;

const Input = styled.input`
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;

  &:disabled {
    background: #f5f5f5;
    cursor: not-allowed;
  }
`;

const SubmitButton = styled.button`
  background: var(--primary-color);
  color: white;
  padding: 0.75rem;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  margin-top: 1rem;

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }

  &:hover:not(:disabled) {
    background: var(--primary-dark);
  }
`;

const ErrorMessage = styled.div`
  color: #dc2626;
  background: #fee2e2;
  padding: 0.75rem;
  border-radius: 4px;
  margin-bottom: 1rem;
`;

const SuccessMessage = styled.div`
  color: #059669;
  background: #d1fae5;
  padding: 1rem;
  border-radius: 4px;
  text-align: center;
  margin: 1rem 0;
`;

export default ParentProfileForm;

========================================================================================
FILE: src/pages/profile/ParentProfile/components/StudentProgressTracker.tsx
========================================================================================
import React from 'react';
import styled from 'styled-components';
import { Student } from '../../../../types/student';

interface StudentProgressTrackerProps {
  studentData?: Student[];
}

const StudentProgressTracker: React.FC<StudentProgressTrackerProps> = ({ studentData }) => {
  return (
    <ProgressContainer>
      <h3>Student Progress Overview</h3>
      {studentData?.map(student => (
        <ProgressCard key={student.id}>
          <h4>{student.name}</h4>
          <ProgressBar>
            <Progress width={75} />
          </ProgressBar>
        </ProgressCard>
      ))}
    </ProgressContainer>
  );
};

const ProgressContainer = styled.div`
  padding: 20px;
  background: white;
  border-radius: 8px;
  margin-bottom: 20px;
`;

const ProgressCard = styled.div`
  margin: 15px 0;
`;

const ProgressBar = styled.div`
  width: 100%;
  height: 10px;
  background: #eee;
  border-radius: 5px;
  overflow: hidden;
`;

const Progress = styled.div<{ width: number }>`
  width: ${props => props.width}%;
  height: 100%;
  background: #4CAF50;
  transition: width 0.3s ease;
`;

export default StudentProgressTracker;

========================================================================================
FILE: src/pages/profile/ParentProfile/dashboard/components/CurriculumApproval.tsx
========================================================================================
import React from 'react';
import styled from 'styled-components';
import { Student } from '../../../../../types/auth';

interface CurriculumApprovalProps {
  studentData?: Student[];
}

const CurriculumApproval: React.FC<CurriculumApprovalProps> = ({ studentData }) => {
  return (
    <ApprovalContainer>
      <h3>Pending Curriculum Approvals</h3>
      {studentData?.map(student => (
        <ApprovalCard key={student.id}>
          <h4>{student.name}</h4>
          <ApprovalActions>
            <button className="approve">Approve</button>
            <button className="review">Review</button>
          </ApprovalActions>
        </ApprovalCard>
      ))}
    </ApprovalContainer>
  );
};

const ApprovalContainer = styled.div`
  padding: 20px;
  background: white;
  border-radius: 8px;
`;

const ApprovalCard = styled.div`
  margin: 15px 0;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 4px;
`;

const ApprovalActions = styled.div`
  display: flex;
  gap: 10px;
  margin-top: 10px;

  button {
    padding: 5px 15px;
    border-radius: 4px;
    border: none;
    cursor: pointer;

    &.approve {
      background: #4CAF50;
      color: white;
    }

    &.review {
      background: #FFA726;
      color: white;
    }
  }
`;

export default CurriculumApproval;

========================================================================================
FILE: src/pages/profile/ParentProfile/dashboard/components/NotificationCenter.tsx
========================================================================================
import React from 'react';
import styled from 'styled-components';

const NotificationCenter: React.FC = () => {
  return (
    <NotificationContainer>
      <h3>Notifications</h3>
      <NotificationList>
        {/* Placeholder for notifications */}
        <NotificationItem>
          <span>No new notifications</span>
        </NotificationItem>
      </NotificationList>
    </NotificationContainer>
  );
};

const NotificationContainer = styled.div`
  padding: 20px;
  background: white;
  border-radius: 8px;
  margin-bottom: 20px;
`;

const NotificationList = styled.div`
  margin-top: 15px;
`;

const NotificationItem = styled.div`
  padding: 10px;
  border-bottom: 1px solid #eee;
  &:last-child {
    border-bottom: none;
  }
`;

export default NotificationCenter;

========================================================================================
FILE: src/pages/profile/StudentProfile/StudentDashboard.tsx
========================================================================================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { motion as m } from 'framer-motion';
import styled from 'styled-components';
import { FaGraduationCap, FaChartLine, FaBook } from 'react-icons/fa';
import { useAuth } from '../../../contexts/AuthContext';
import { getStudentProfile } from '../../../services/profileService';
import { Student } from '../../../types/auth';
import LoadingSpinner from '../../../components/common/LoadingSpinner';
import LearningStyleChat from '../../../components/chat/LearningStyleChat';
import { DefaultTheme } from 'styled-components';

interface ThemeProps {
  theme: DefaultTheme;
}

interface StudentData extends Student {
  recentActivities: Array<{
    id?: string;
    type: string;
    name: string;
    date: string;
  }>;
  progress: Array<{
    type: string;
    value: number;
  }>;
}

const StudentDashboard: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { currentUser } = useAuth();
  const [studentData, setStudentData] = useState<StudentData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>('');
  const [needsSetup, setNeedsSetup] = useState(false);
  const [reloadToken, setReloadToken] = useState(0);

  const logDebug = (...args: unknown[]) => {
    if (import.meta.env.DEV) {
      console.debug(...args);
    }
  };

  const fetchWithTimeout = async <T,>(promise: Promise<T>, timeoutMs: number) => {
    let timeoutId: number | undefined;
    const timeoutPromise = new Promise<T>((_, reject) => {
      timeoutId = window.setTimeout(() => {
        reject(new Error('Timed out loading dashboard data'));
      }, timeoutMs);
    });

    return Promise.race([promise, timeoutPromise]).finally(() => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    });
  };

  const handleRetry = () => {
    setLoading(true);
    setError('');
    setNeedsSetup(false);
    setReloadToken((value) => value + 1);
  };

  useEffect(() => {
    const fetchStudentData = async () => {
      const studentId = id ?? currentUser?.uid;
      setError('');
      setNeedsSetup(false);

      if (!studentId) {
        setError('Student ID not found');
        setLoading(false);
        return;
      }

      try {
        logDebug('Dashboard load start', studentId);
        const data = await fetchWithTimeout(getStudentProfile(studentId), 8000);
        if (data) {
          setStudentData({
            ...data,
            id: data.id || studentId,
            recentActivities: [],
            progress: []
          } as StudentData);
          logDebug('Dashboard load success', { data });
        } else {
          setStudentData(null);
          setNeedsSetup(true);
          logDebug('Dashboard load success', { data: null });
        }
      } catch (err) {
        logDebug('Dashboard load error', err);
        const message = err instanceof Error ? err.message : 'Failed to load student data';
        if (message.toLowerCase().includes('not found')) {
          setNeedsSetup(true);
          setStudentData(null);
        } else {
          setError(message);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchStudentData();
  }, [currentUser?.uid, id, reloadToken]);

  if (loading) {
    return (
      <StyledLoadingContainer>
        <LoadingSpinner />
      </StyledLoadingContainer>
    );
  }

  if (error) {
    return (
      <StyledErrorContainer>
        <p>{error}</p>
        <StyledRetryButton type="button" onClick={handleRetry}>Retry</StyledRetryButton>
      </StyledErrorContainer>
    );
  }

  if (needsSetup) {
    return (
      <StyledSetupContainer>
        <h2>Finish setting up your dashboard</h2>
        <p>No student profile was found yet. Complete your setup to start tracking progress.</p>
        <StyledRetryButton type="button" onClick={handleRetry}>Retry</StyledRetryButton>
      </StyledSetupContainer>
    );
  }

  return (
    <m.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
    >
      <StyledHeader>
        <StyledHeaderLeft>
          <h1>Welcome, {studentData?.name}!</h1>
          <p>Grade {studentData?.grade}</p>
        </StyledHeaderLeft>
      </StyledHeader>

      <DashboardGrid>
        <MainSection>
          {!studentData?.hasTakenAssessment && (
            <AssessmentSection>
              <h2>Learning Style Assessment</h2>
              <p>Take your learning style assessment to get personalized recommendations.</p>
              <LearningStyleChat />
            </AssessmentSection>
          )}

          {studentData?.hasTakenAssessment && studentData.learningStyle && (
            <LearningStyleSection>
              <h2>Your Learning Style: {studentData.learningStyle}</h2>
              <p>Based on your assessment, we've customized your learning experience.</p>
            </LearningStyleSection>
          )}

          <ProgressSection>
            <h2>Recent Progress</h2>
            {/* Add progress visualization here */}
          </ProgressSection>
        </MainSection>
      </DashboardGrid>
    </m.div>
  );
};

const DashboardContainer = styled(m.div)`
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
`;

const StyledLoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 400px;
`;

const StyledErrorContainer = styled.div`
  text-align: center;
  color: red;
  padding: 2rem;
  display: grid;
  gap: 1rem;
`;

const StyledSetupContainer = styled.div`
  text-align: center;
  padding: 2rem;
  background: #fff7ed;
  border: 1px solid #fdba74;
  border-radius: 12px;
  display: grid;
  gap: 0.75rem;
  color: #9a3412;
`;

const StyledRetryButton = styled.button`
  margin: 0 auto;
  padding: 0.6rem 1.5rem;
  border-radius: 999px;
  border: none;
  background: var(--primary-color);
  color: white;
  cursor: pointer;
  font-weight: 600;

  &:hover {
    background: var(--primary-dark);
  }
`;

const StyledHeader = styled(m.header)`
  margin-bottom: 2rem;
`;

const StyledHeaderLeft = styled.div`
  h1 {
    margin: 0;
    color: var(--primary-color);
  }
  p {
    margin: 0.5rem 0 0;
    color: var(--text-secondary);
  }
`;

const DashboardGrid = styled.div`
  display: grid;
  gap: 2rem;
`;

const MainSection = styled.div`
  display: grid;
  gap: 2rem;
`;

const AssessmentSection = styled.div`
  background: white;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
`;

const LearningStyleSection = styled.div`
  background: white;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
`;

const ProgressSection = styled.div`
  background: white;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
`;

export default StudentDashboard;

========================================================================================
FILE: src/pages/profile/StudentProfile/StudentProfile.tsx
========================================================================================
import React, { useState } from "react";
import styled from "styled-components";
import CourseCard from "../../../components/CourseCard";

interface Course {
  title: string;
  type: "Video Animated" | "Quiz" | "Mind Map";
  category: string;
}

const StudentProfile: React.FC = () => {
  const [filter, setFilter] = useState<string>("");

  const courses: Course[] = [
    { title: "Introduction to Learning Styles", type: "Video Animated", category: "Learning Fundamentals" },
    { title: "Learning Style Quiz", type: "Quiz", category: "Assessment" },
    { title: "Visual Learning Techniques", type: "Mind Map", category: "Learning Techniques" }
  ];

  return (
    <Container>
      <ProfileBox>
        <Title>Student Profile</Title>
        
        {/* Search Filter */}
        <input
          type="text"
          placeholder="Search courses..."
          className="border px-4 py-2 w-full mb-4 rounded-lg"
          value={filter}
          onChange={(e) => setFilter(e.target.value)}
        />

        {/* Course List */}
        <div className="grid grid-cols-3 gap-4">
          {courses
            .filter((course) => course.title.toLowerCase().includes(filter.toLowerCase()))
            .map((course, index) => (
              <CourseCard key={index} {...course} />
            ))}
        </div>
      </ProfileBox>
    </Container>
  );
};

const Container = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: 20px;
  background-color: #f5f5f5;
`;

const ProfileBox = styled.div`
  width: 100%;
  max-width: 400px;
  background: white;
  border-radius: 8px;
  padding: 2rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
`;

const Title = styled.h2`
  text-align: center;
  color: #2C3E50;
  margin-bottom: 1.5rem;
  font-size: 1.75rem;
`;

export default StudentProfile;

========================================================================================
FILE: src/pages/profile/StudentProfile/StudentProfileForm.tsx
========================================================================================
import React, { useState } from 'react';
import { addDoc, collection } from 'firebase/firestore';
import { auth, firestore as db } from '../../../config/firebase';
import styled from 'styled-components';

interface StudentFormData {
  firstName: string;
  lastName: string;
  age: string;
  grade: string;
}

interface FormState {
  loading: boolean;
  error: string | null;
  success: boolean;
}

export const StudentProfileForm: React.FC = () => {
  const [formData, setFormData] = useState<StudentFormData>({
    firstName: '',
    lastName: '',
    age: '',
    grade: ''
  });

  const [formState, setFormState] = useState<FormState>({
    loading: false,
    error: null,
    success: false
  });

  const resetForm = () => {
    setFormData({
      firstName: '',
      lastName: '',
      age: '',
      grade: ''
    });
    setFormState({
      loading: false,
      error: null,
      success: false
    });
  };

  const validateForm = (): boolean => {
    if (!formData.firstName.trim() || !formData.lastName.trim()) {
      setFormState(prev => ({ ...prev, error: 'First and last name are required' }));
      return false;
    }
    if (!formData.age || parseInt(formData.age) < 4 || parseInt(formData.age) > 18) {
      setFormState(prev => ({ ...prev, error: 'Age must be between 4 and 18' }));
      return false;
    }
    if (!formData.grade.trim()) {
      setFormState(prev => ({ ...prev, error: 'Grade is required' }));
      return false;
    }
    return true;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const parentId = auth.currentUser?.uid;
    
    if (!parentId) {
      setFormState(prev => ({ ...prev, error: 'Parent authentication required' }));
      return;
    }

    if (!validateForm()) return;

    setFormState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      await addDoc(collection(db, 'students'), {
        ...formData,
        parentId,
        createdAt: new Date().toISOString()
      });
      
      setFormState({ loading: false, error: null, success: true });
      setTimeout(resetForm, 3000);
    } catch (error) {
      setFormState({
        loading: false,
        error: error instanceof Error ? error.message : 'An error occurred',
        success: false
      });
    }
  };

  return (
    <FormContainer>
      {formState.success && (
        <SuccessMessage>Student added successfully!</SuccessMessage>
      )}
      {formState.error && (
        <ErrorMessage>{formState.error}</ErrorMessage>
      )}
      <Form onSubmit={handleSubmit}>
        <FormGroup>
          <Label>First Name *</Label>
          <Input
            type="text"
            value={formData.firstName}
            onChange={(e) => setFormData({...formData, firstName: e.target.value})}
            disabled={formState.loading}
            required
          />
        </FormGroup>
        <FormGroup>
          <Label>Last Name *</Label>
          <Input
            type="text"
            value={formData.lastName}
            onChange={(e) => setFormData({...formData, lastName: e.target.value})}
            disabled={formState.loading}
            required
          />
        </FormGroup>
        <FormGroup>
          <Label>Age *</Label>
          <Input
            type="number"
            min="4"
            max="18"
            value={formData.age}
            onChange={(e) => setFormData({...formData, age: e.target.value})}
            disabled={formState.loading}
            required
          />
        </FormGroup>
        <FormGroup>
          <Label>Grade *</Label>
          <Input
            type="text"
            value={formData.grade}
            onChange={(e) => setFormData({...formData, grade: e.target.value})}
            disabled={formState.loading}
            required
          />
        </FormGroup>
        <SubmitButton type="submit" disabled={formState.loading}>
          {formState.loading ? 'Adding Student...' : 'Add Student'}
        </SubmitButton>
      </Form>
    </FormContainer>
  );
};

const FormContainer = styled.div`
  max-width: 500px;
  margin: 2rem auto;
  padding: 2rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
`;

const Form = styled.form`
  display: flex;
  flex-direction: column;
  gap: 1rem;
`;

const FormGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
`;

const Label = styled.label`
  font-weight: 500;
  color: var(--text-color);
`;

const Input = styled.input`
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;

  &:focus {
    outline: none;
    border-color: var(--primary-color);
  }

  &:disabled {
    background: #f5f5f5;
    cursor: not-allowed;
  }
`;

const SubmitButton = styled.button`
  padding: 0.75rem;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  transition: background 0.2s;

  &:hover:not(:disabled) {
    background: var(--secondary-color);
  }

  &:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
`;

const Message = styled.div`
  padding: 1rem;
  margin-bottom: 1rem;
  border-radius: 4px;
`;

const SuccessMessage = styled(Message)`
  background: var(--success-color);
  color: white;
`;

const ErrorMessage = styled(Message)`
  background: var(--danger-color);
  color: white;
`;

export default StudentProfileForm;

========================================================================================
FILE: src/components/chat/LearningStyleChat.tsx
========================================================================================
import React, { useState, useRef, useEffect } from 'react';
import styled from 'styled-components';
import { FaPaperPlane } from 'react-icons/fa';
import { useAuth } from '../../contexts/AuthContext';
import Message from '../Message';
import { saveLearningStyle, updateStudentAssessmentStatus } from '../../services/profileService';
import { CheshireService } from '../../services/cheshireService';
import { LearningStyle } from '../../types/profiles';
import Button from '../common/Button';

type ValidLearningStyle = 'visual' | 'auditory' | 'kinesthetic' | 'reading/writing';

interface ChatMessage {
  text: string;
  sender: 'user' | 'bot';
}

interface CheshireResponse {
  data: string;
  memories?: Array<{
    metadata?: {
      learning_style?: string;
    };
  }>;
}

interface CheshireError {
  code?: string;
  message: string;
}

const isValidLearningStyle = (style: string): style is ValidLearningStyle => {
  return ['visual', 'auditory', 'kinesthetic', 'reading/writing'].includes(style);
};

const MAX_RETRIES = 3;
const RETRY_DELAY = 1000; // 1 second

const LearningStyleChat: React.FC<{ studentId?: string }> = ({ studentId }) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [connectionError, setConnectionError] = useState(false);
  const chatEndRef = useRef<HTMLDivElement>(null);
  const { currentUser } = useAuth();

  // Initialize chat with assessment start message
  useEffect(() => {
    setMessages([{ 
      text: "Hi! I'm here to help assess your learning style. Let's start with a few questions. How do you prefer to learn new things?", 
      sender: "bot" 
    }]);
  }, []);

  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Check API connection on mount and set up periodic checks
  useEffect(() => {
    checkApiConnection();
    const intervalId = setInterval(checkApiConnection, 30000); // Check every 30 seconds
    return () => clearInterval(intervalId);
  }, []);

  const checkApiConnection = async (): Promise<void> => {
    const isConnected = await CheshireService.checkConnection();
    setConnectionError(!isConnected);
  };

  const retryWithDelay = async (fn: () => Promise<void>, maxRetries = 3, delay = 1000): Promise<void> => {
    try {
      return await fn();
    } catch (error) {
      if (maxRetries > 0) {
        await new Promise(resolve => setTimeout(resolve, delay));
        return retryWithDelay(fn, maxRetries - 1, delay);
      }
      throw error;
    }
  };

  const handleResponse = async (response: CheshireResponse): Promise<void> => {
    const rawLearningStyle = response?.memories?.find(m => m.metadata?.learning_style)?.metadata?.learning_style;
    if (rawLearningStyle && isValidLearningStyle(rawLearningStyle) && studentId) {
      const learningStyle: LearningStyle = {
        type: rawLearningStyle,
        strengths: [],
        recommendations: []
      };
      try {
        await saveLearningStyle(studentId, learningStyle);
        await updateStudentAssessmentStatus(studentId, "completed");
      } catch (error) {
        console.error('Error saving learning style:', error);
        setMessages(prev => [...prev, { 
          text: "There was an error saving your learning style. Please try again.", 
          sender: "bot" 
        }]);
      }
    }
  };

  const sendMessage = async (): Promise<void> => {
    if (!input.trim()) return;

    const userMessage = input.trim();
    setInput('');
    setMessages(prev => [...prev, { text: userMessage, sender: 'user' }]);

    try {
      setLoading(true);
      const response = await CheshireService.sendChatMessage(
        userMessage,
        currentUser?.uid || 'anonymous',
        studentId || 'default'
      );

      if (response) {
        setMessages(prev => [...prev, { text: response.data, sender: 'bot' }]);
        await handleResponse(response);
      }
      
      setConnectionError(false);
    } catch (error: unknown) {
      console.error('Error sending message:', error);
      const errorMessage = CheshireService.getErrorMessage(error as CheshireError);
      setMessages(prev => [...prev, { text: errorMessage, sender: 'bot' }]);
      setConnectionError(true);
      await checkApiConnection();
    } finally {
      setLoading(false);
    }
  };

  return (
    <ChatContainer className="card">
      <ChatHeader>
        🎓 Learning Style Assessment
        {connectionError && (
          <ConnectionError>
            ⚠️ Connection Error - Check if the chat service is running
          </ConnectionError>
        )}
      </ChatHeader>
      <ChatBody>
        {messages.map((msg, index) => (
          <Message key={index} sender={msg.sender}>{msg.text}</Message>
        ))}
        {loading && <Message sender="bot">Typing...</Message>}
        <div ref={chatEndRef} />
      </ChatBody>
      <ChatFooter>
        <ChatInput
          type="text"
          value={input}
          placeholder="Type your response..."
          onChange={(e) => setInput(e.target.value)}
          onKeyPress={(e) => e.key === "Enter" && sendMessage()}
          className="form-input"
        />
        <Button onClick={sendMessage} $variant="primary">
          <FaPaperPlane />
        </Button>
      </ChatFooter>
    </ChatContainer>
  );
};

const ChatContainer = styled.div`
  height: 500px;
  display: flex;
  flex-direction: column;
`;

const ChatHeader = styled.div`
  padding: var(--spacing-md);
  border-bottom: 1px solid #eee;
  font-weight: bold;
`;

const ConnectionError = styled.div`
  color: var(--color-error);
  font-size: 0.8em;
  margin-top: 4px;
`;

const ChatBody = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: var(--spacing-md);
`;

const ChatFooter = styled.div`
  display: flex;
  gap: var(--spacing-sm);
  padding: var(--spacing-md);
  border-top: 1px solid #eee;
`;

const ChatInput = styled.input`
  flex: 1;
`;

export default LearningStyleChat;

========================================================================================
FILE: src/components/chat/ChatUI.tsx
========================================================================================
import React, { useState } from 'react';
import { CheshireService } from '../../services/cheshireService';
import { useAuth } from '../../contexts/AuthContext';
import './ChatUI.css';

interface Message {
  sender: 'user' | 'tutor';
  text: string;
}

const ChatUI: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputText, setInputText] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const { currentUser } = useAuth();

  const handleSend = async () => {
    if (!inputText.trim() || !currentUser?.uid) return;
    
    const userMessage: Message = { sender: 'user', text: inputText };
    setMessages(prev => [...prev, userMessage]);
    setIsProcessing(true);

    try {
      const chatId = 'default';
      const response = await CheshireService.sendChatMessage(
        inputText,
        currentUser.uid,
        chatId
      );

      const tutorMessage: Message = {
        sender: 'tutor',
        text: response.data
      };
      setMessages(prev => [...prev, tutorMessage]);

      const memories = response.memories || [];
      if (memories.length > 0) {
        const learningStyleMemory = memories.find(
          memory => memory.metadata?.learning_style
        );
        if (learningStyleMemory?.metadata?.learning_style) {
          console.log('Learning style detected:', learningStyleMemory.metadata.learning_style);
        }
      }
    } catch (error) {
      const errorMessage = CheshireService.getErrorMessage(error);
      setMessages(prev => [...prev, { sender: 'tutor', text: errorMessage }]);
    } finally {
      setIsProcessing(false);
    }
    setInputText('');
  };

  return (
    <div className="chat-container">
      <div className="chat-window">
        {messages.map((msg, idx) => (
          <div key={idx} className={`message ${msg.sender}`}>
            {msg.text}
          </div>
        ))}
        {isProcessing && (
          <div className="message tutor processing">
            Thinking...
          </div>
        )}
      </div>
      <div className="input-container">
        <input
          type="text"
          value={inputText}
          placeholder="Type your message..."
          onChange={(e) => setInputText(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && !isProcessing && handleSend()}
          disabled={isProcessing}
        />
        <button 
          onClick={handleSend}
          disabled={isProcessing || !inputText.trim()}
        >
          Send
        </button>
      </div>
    </div>
  );
};

export default ChatUI;

========================================================================================
FILE: src/hooks/useVARKAssessment.ts
========================================================================================
import { useState, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { 
  saveAssessmentResults, 
  startAssessment, 
  sendUserResponse 
} from '../services/varkService';

interface Message {
  text: string;
  sender: 'user' | 'ai';
  timestamp: string;
}

interface Assessment {
  inProgress: boolean;
  currentQuestionIndex: number;
  assessmentId?: string;
  isComplete?: boolean;
  answers: Array<{
    question: string;
    answer: string;
  }>;
  results: {
    visual: number;
    auditory: number;
    readWrite: number;
    kinesthetic: number;
    primaryStyle: string;
  } | null;
}

export const useVARKAssessment = () => {
  const { currentUser } = useAuth();
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [assessment, setAssessment] = useState<Assessment>({
    inProgress: false,
    currentQuestionIndex: 0,
    answers: [],
    results: null
  });

  // Initialize assessment when component mounts
  useEffect(() => {
    const initializeChat = async () => {
      if (currentUser && !assessment.inProgress) {
        setIsLoading(true);
        try {
          const response = await startAssessment(currentUser.uid);
          setMessages([{
            text: response.initialMessage,
            sender: 'ai',
            timestamp: new Date().toISOString()
          }]);
          
          setAssessment(prev => ({
            ...prev,
            inProgress: true,
            assessmentId: response.assessmentId
          }));
        } catch (error) {
          console.error('Error starting assessment:', error);
          setMessages([{
            text: 'Sorry, there was an error starting the assessment. Please try again.',
            sender: 'ai',
            timestamp: new Date().toISOString()
          }]);
        } finally {
          setIsLoading(false);
        }
      }
    };
    
    initializeChat();
  }, [currentUser]);

  const sendMessage = async (messageText: string) => {
    if (!currentUser?.uid || !assessment.assessmentId) return;

    const userMessage: Message = {
      text: messageText,
      sender: 'user',
      timestamp: new Date().toISOString()
    };
    
    setMessages(prev => [...prev, userMessage]);
    setIsLoading(true);
    
    try {
      const response = await sendUserResponse({
        userId: currentUser.uid,
        assessmentId: assessment.assessmentId,
        message: messageText,
        questionIndex: assessment.currentQuestionIndex
      });
      
      setMessages(prev => [...prev, {
        text: response.message,
        sender: 'ai',
        timestamp: new Date().toISOString()
      }]);
      
      setAssessment(prev => ({
        ...prev,
        currentQuestionIndex: response.nextQuestionIndex,
        answers: [...prev.answers, {
          question: response.currentQuestion,
          answer: messageText
        }],
        results: response.results || null,
        isComplete: response.isComplete
      }));
      
      if (response.isComplete && response.results) {
        await saveAssessmentResults(currentUser.uid, response.results);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      setMessages(prev => [...prev, {
        text: "I'm sorry, there was an error processing your response. Please try again.",
        sender: 'ai',
        timestamp: new Date().toISOString()
      }]);
    } finally {
      setIsLoading(false);
    }
  };

  return {
    messages,
    sendMessage,
    isLoading,
    assessment,
    isComplete: assessment.isComplete || false
  };
};

========================================================================================
FILE: src/components/VARKAssessment/ChatContainer.tsx
========================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import ChatMessage from './ChatMessage';
import ChatInput from './ChatInput';
import TypingIndicator from './TypingIndicator';
import VARKResults from './VARKResults';
import { useVARKAssessment } from '../../hooks/useVARKAssessment';

interface Message {
  text: string;
  sender: 'user' | 'ai';
  timestamp: string;
}

interface VARKResults {
  visual: number;
  auditory: number;
  readWrite: number;
  kinesthetic: number;
  primaryStyle: string;
}

interface Assessment {
  inProgress: boolean;
  currentQuestionIndex: number;
  answers: Array<{
    question: string;
    answer: string;
  }>;
  results: VARKResults | null;
  isComplete?: boolean;
}

const ChatContainer: React.FC = () => {
  const {
    messages,
    sendMessage,
    isLoading,
    assessment,
    isComplete
  } = useVARKAssessment();
  
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <motion.div 
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
      className="max-w-4xl mx-auto bg-white rounded-lg shadow-lg overflow-hidden"
    >
      <div className="p-6 bg-gradient-to-r from-blue-600 to-blue-800 text-white">
        <h2 className="text-2xl font-bold">Learning Style Assessment</h2>
        <p className="mt-2 opacity-90">Let's discover how you learn best through a friendly conversation.</p>
      </div>
      
      <div className="h-[500px] overflow-y-auto p-6 bg-gray-50">
        {messages.map((msg: Message, index: number) => (
          <ChatMessage 
            key={index} 
            message={msg.text} 
            sender={msg.sender} 
            timestamp={msg.timestamp}
          />
        ))}
        
        {isLoading && <TypingIndicator />}
        <div ref={messagesEndRef} />
      </div>
      
      {isComplete ? (
        <VARKResults results={assessment.results!} />
      ) : (
        <div className="p-4 border-t">
          <ChatInput 
            onSendMessage={sendMessage}
            disabled={isLoading} 
          />
        </div>
      )}
    </motion.div>
  );
};

export default ChatContainer;

========================================================================================
FILE: src/components/VARKAssessment/ChatInput.tsx
========================================================================================
import React, { useState, FormEvent } from 'react';
import { motion } from 'framer-motion';

interface ChatInputProps {
  onSendMessage: (message: string) => void;
  disabled?: boolean;
}

const ChatInput: React.FC<ChatInputProps> = ({ onSendMessage, disabled }) => {
  const [message, setMessage] = useState('');

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (message.trim() && !disabled) {
      onSendMessage(message);
      setMessage('');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="flex gap-2">
      <input
        type="text"
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        placeholder="Type your response here..."
        disabled={disabled}
        className="flex-1 px-4 py-2 rounded-full border border-gray-300 focus:outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all disabled:opacity-60"
      />
      <motion.button
        type="submit"
        disabled={disabled || !message.trim()}
        whileHover={{ scale: 1.05 }}
        whileTap={{ scale: 0.95 }}
        className="p-2 rounded-full bg-blue-600 text-white disabled:opacity-60 disabled:cursor-not-allowed"
      >
        <svg 
          viewBox="0 0 24 24" 
          fill="none" 
          stroke="currentColor" 
          strokeWidth="2" 
          strokeLinecap="round" 
          strokeLinejoin="round"
          className="w-5 h-5"
        >
          <path d="M22 2L11 13" />
          <path d="M22 2L15 22L11 13L2 9L22 2Z" />
        </svg>
      </motion.button>
    </form>
  );
};

export default ChatInput;

========================================================================================
FILE: src/components/VARKAssessment/ChatMessage.tsx
========================================================================================
import React from 'react';
import { motion } from 'framer-motion';

interface ChatMessageProps {
  message: string;
  sender: 'user' | 'ai';
  timestamp: string;
}

const ChatMessage: React.FC<ChatMessageProps> = ({ message, sender, timestamp }) => {
  const isUser = sender === 'user';
  const formattedTime = new Date(timestamp).toLocaleTimeString([], {
    hour: '2-digit',
    minute: '2-digit'
  });
  
  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}
    >
      <div className={`max-w-[80%] rounded-2xl px-4 py-3 ${
        isUser 
          ? 'bg-blue-600 text-white ml-auto rounded-br-sm' 
          : 'bg-white shadow-md rounded-bl-sm'
      }`}>
        <p className="text-sm sm:text-base whitespace-pre-wrap">{message}</p>
        <div className={`text-xs mt-1 ${isUser ? 'text-blue-100' : 'text-gray-500'}`}>
          {formattedTime} • {isUser ? 'You' : 'AI Tutor'}
        </div>
      </div>
    </motion.div>
  );
};

export default ChatMessage;

========================================================================================
FILE: src/components/VARKAssessment/VARKResults.tsx
========================================================================================
import React from 'react';
import { motion } from 'framer-motion';
import { Radar } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  RadialLinearScale,
  PointElement,
  LineElement,
  Filler,
  Tooltip,
  Legend
} from 'chart.js';

// Register ChartJS components
ChartJS.register(
  RadialLinearScale,
  PointElement,
  LineElement,
  Filler,
  Tooltip,
  Legend
);

interface VARKResultsProps {
  results: {
    visual: number;
    auditory: number;
    readWrite: number;
    kinesthetic: number;
    primaryStyle: string;
  };
}

const VARKResults: React.FC<VARKResultsProps> = ({ results }) => {
  const { visual, auditory, readWrite, kinesthetic, primaryStyle } = results;
  
  const data = {
    labels: ['Visual', 'Auditory', 'Read/Write', 'Kinesthetic'],
    datasets: [
      {
        label: 'Your Learning Style',
        data: [visual, auditory, readWrite, kinesthetic],
        backgroundColor: 'rgba(59, 130, 246, 0.2)',
        borderColor: 'rgb(59, 130, 246)',
        borderWidth: 2,
        pointBackgroundColor: 'rgb(59, 130, 246)',
        pointHoverRadius: 6,
      },
    ],
  };

  const options = {
    scales: {
      r: {
        beginAtZero: true,
        max: 100,
        ticks: {
          stepSize: 20,
        },
      },
    },
    plugins: {
      legend: {
        display: false,
      },
    },
  };

  const getLearningTips = (style: string) => {
    const tips = {
      Visual: [
        'Use diagrams, charts, and mind maps',
        'Watch educational videos and demonstrations',
        'Highlight text in different colors',
        'Create visual summaries of concepts',
      ],
      Auditory: [
        'Record and replay lectures',
        'Participate in group discussions',
        'Use text-to-speech for reading materials',
        'Explain concepts out loud to yourself',
      ],
      'Read/Write': [
        'Take detailed notes during lectures',
        'Rewrite information in your own words',
        'Create lists and summaries',
        'Practice writing explanations',
      ],
      Kinesthetic: [
        'Use hands-on learning activities',
        'Take breaks to move around while studying',
        'Create physical models or diagrams',
        'Use role-playing to understand concepts',
      ],
    }[style] || [];

    return tips;
  };

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.5 }}
      className="p-6 bg-white"
    >
      <h2 className="text-2xl font-bold text-center mb-6">Your VARK Learning Style Results</h2>
      
      <div className="grid md:grid-cols-2 gap-8">
        <div className="aspect-square">
          <Radar data={data} options={options} />
        </div>
        
        <div>
          <div className="mb-6">
            <h3 className="text-xl font-semibold mb-2">
              Your Primary Learning Style:
            </h3>
            <div className="text-2xl font-bold text-blue-600">
              {primaryStyle}
            </div>
          </div>

          <div>
            <h3 className="text-xl font-semibold mb-4">
              Recommended Learning Strategies:
            </h3>
            <ul className="space-y-3">
              {getLearningTips(primaryStyle).map((tip, index) => (
                <motion.li
                  key={index}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  transition={{ delay: index * 0.1 }}
                  className="flex items-center gap-2"
                >
                  <span className="text-blue-600">•</span>
                  {tip}
                </motion.li>
              ))}
            </ul>
          </div>
        </div>
      </div>
    </motion.div>
  );
};

export default VARKResults;

========================================================================================
FILE: src/services/profileService.ts
========================================================================================
import { doc, getDoc, setDoc, updateDoc, collection, addDoc, arrayUnion } from 'firebase/firestore';
import { firestore } from '../config/firebase';
import { Parent, Student, LearningStyle } from "../types/profiles";

// Cache for storing profiles
const profileCache = new Map();

export const invalidateProfileCache = (key?: string) => {
  if (!key) {
    profileCache.clear();
    return;
  }
  profileCache.delete(key);
};

export const invalidateParentCache = (parentId: string) => {
  invalidateProfileCache(`parent_${parentId}`);
};

export const invalidateStudentCache = (studentId: string) => {
  invalidateProfileCache(`student_${studentId}`);
};

// Helper to check online status
const isOnline = () => navigator.onLine;

// Helper to handle offline errors
const handleOfflineError = (operation: string) => {
  const error = new Error(`Cannot ${operation} while offline`);
  error.name = 'OfflineError';
  return error;
};

// ✅ Create Parent Profile
export const createParentProfile = async (parentData: Partial<Parent>): Promise<string> => {
  try {
    if (!parentData.uid) throw new Error('User ID is required');
    
    const now = new Date().toISOString();
    const parentRef = doc(firestore, 'parents', parentData.uid);
    await setDoc(parentRef, {
      uid: parentData.uid,
      email: parentData.email ?? '',
      displayName: parentData.displayName ?? '',
      students: [],
      createdAt: now,
      updatedAt: now,
      ...(parentData.phone ? { phone: parentData.phone } : {})
    });
    
    console.log('✅ Parent profile created successfully:', parentData.uid);
    return parentData.uid;
  } catch (error) {
    console.error('❌ Error creating parent profile:', error);
    throw error;
  }
};

// ✅ Fetch Parent Profile
export const getParentProfile = async (userId: string): Promise<Parent | null> => {
  try {
    console.log('🔍 Fetching parent profile for:', userId);

    // Check cache first
    if (profileCache.has(`parent_${userId}`)) {
      return profileCache.get(`parent_${userId}`);
    }

    const docRef = doc(firestore, 'parents', userId);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      const data = docSnap.data();
      const parentProfile: Parent = {
        uid: data.uid || userId,
        email: data.email || '',
        displayName: data.displayName || '',
        students: data.students || [],
        createdAt: data.createdAt || new Date().toISOString(),
        updatedAt: data.updatedAt || new Date().toISOString()
      };
      console.log('✅ Parent profile found:', parentProfile);
      // Cache the result
      profileCache.set(`parent_${userId}`, parentProfile);
      return parentProfile;
    }
    
    console.log('ℹ️ No parent profile found, creating one...');
    // If no profile exists, create one
    await createParentProfile({ uid: userId });
    return getParentProfile(userId); // Retry fetch after creation
    
  } catch (error) {
    if (!isOnline()) {
      console.warn('Offline: Using cached data if available');
      return profileCache.get(`parent_${userId}`) || null;
    }
    console.error('❌ Error fetching parent profile:', error);
    throw error;
  }
};

// ✅ Fetch Student Profile
export const getStudentProfile = async (studentId: string): Promise<Student> => {
  try {
    // Check cache first
    if (profileCache.has(`student_${studentId}`)) {
      return profileCache.get(`student_${studentId}`);
    }

    const studentRef = doc(firestore, "students", studentId);
    const studentDoc = await getDoc(studentRef);

    if (!studentDoc.exists()) {
      throw new Error("Student profile not found");
    }

    const studentData = studentDoc.data() as Student;
    // Cache the result
    profileCache.set(`student_${studentId}`, studentData);
    return studentData;
  } catch (error) {
    if (!isOnline()) {
      console.warn('Offline: Using cached data if available');
      return profileCache.get(`student_${studentId}`) || null;
    }
    throw error;
  }
};

export const getStudentsByIds = async (ids: string[]): Promise<Student[]> => {
  if (!ids.length) {
    return [];
  }

  const students = await Promise.all(
    ids.map(async (studentId) => {
      const cacheKey = `student_${studentId}`;
      if (profileCache.has(cacheKey)) {
        return profileCache.get(cacheKey) as Student;
      }

      const studentRef = doc(firestore, 'students', studentId);
      const studentDoc = await getDoc(studentRef);
      if (!studentDoc.exists()) {
        return null;
      }

      const studentData = studentDoc.data() as Student;
      const studentProfile = {
        ...studentData,
        id: studentData.id || studentId
      };
      profileCache.set(cacheKey, studentProfile);
      return studentProfile;
    })
  );

  return students.filter((student): student is Student => Boolean(student));
};

// ✅ Add Student Profile
export const addStudentProfile = async (parentId: string, studentData: {
  name: string;
  grade: string;
  hasTakenAssessment: boolean;
}) => {
  try {
    console.log('📝 Adding student profile for parent:', parentId);
    const now = new Date().toISOString();
    
    // Add the student to the students collection
    const studentRef = await addDoc(collection(firestore, 'students'), {
      ...studentData,
      parentId,
      createdAt: now,
      updatedAt: now
    });

    // Update the parent's students array
    const parentRef = doc(firestore, 'parents', parentId);
    await updateDoc(parentRef, {
      students: arrayUnion(studentRef.id),
      updatedAt: now
    });

    invalidateParentCache(parentId);

    console.log('✅ Student profile added successfully:', studentRef.id);
    return studentRef.id;
  } catch (error) {
    console.error('❌ Error adding student profile:', error);
    throw error;
  }
};

// ✅ Update Student's Assessment Status
export const updateStudentAssessmentStatus = async (studentId: string, status: string) => {
  if (!isOnline()) {
    throw handleOfflineError('update assessment status');
  }

  const studentRef = doc(firestore, "students", studentId);
  try {
    await updateDoc(studentRef, {
      hasTakenAssessment: status === 'completed',
      assessmentStatus: status,
      updatedAt: new Date().toISOString(),
    });

    // Update cache
    const cachedData = profileCache.get(`student_${studentId}`);
    if (cachedData) {
      profileCache.set(`student_${studentId}`, {
        ...cachedData,
        hasTakenAssessment: status === 'completed',
        assessmentStatus: status,
        updatedAt: new Date().toISOString()
      });
    }
    console.log(`Assessment status updated to: ${status}`);
  } catch (error) {
    console.error("Error updating assessment status:", error);
    throw new Error("Failed to update assessment status");
  }
};

// ✅ Save Learning Style
export const saveLearningStyle = async (studentId: string, learningStyle: LearningStyle): Promise<void> => {
  if (!isOnline()) {
    throw handleOfflineError('save learning style');
  }

  try {
    console.log('📝 Saving learning style for student:', studentId);
    const studentRef = doc(firestore, 'students', studentId);
    
    await updateDoc(studentRef, {
      learningStyle,
      updatedAt: new Date().toISOString()
    });

    // Update cache
    const cachedData = profileCache.get(`student_${studentId}`);
    if (cachedData) {
      profileCache.set(`student_${studentId}`, {
        ...cachedData,
        learningStyle,
        updatedAt: new Date().toISOString()
      });
    }
    
    console.log('✅ Learning style saved successfully');
  } catch (error) {
    console.error('❌ Error saving learning style:', error);
    throw error;
  }
};

// Listen for online/offline events to manage cache
window.addEventListener('online', () => {
  console.info('Back online. Syncing data...');
  // Could add sync logic here if needed
});

window.addEventListener('offline', () => {
  console.warn('Gone offline. Using cached data...');
});

export class ProfileService {
  async getUserProfile(userId: string): Promise<any> {
    // ...existing API call logic...
    // Example:
    const response = await fetch(`/api/profiles/${userId}`);
    return response.json();
  }
}

========================================================================================
FILE: src/services/firestore.ts
========================================================================================
import { doc, getDoc, setDoc } from 'firebase/firestore';
import { firestore } from '../config/firebase';

export async function getData(collectionName: string, docId: string) {
  const docRef = doc(firestore, collectionName, docId);
  const docSnap = await getDoc(docRef);
  return docSnap.exists() ? docSnap.data() : null;
}

export async function setData(collectionName: string, docId: string, data: any) {
  const docRef = doc(firestore, collectionName, docId);
  await setDoc(docRef, data, { merge: true });
  return true;
}

// ...other helper functions as needed...

========================================================================================
FILE: src/services/firebaseService.ts
========================================================================================
// frontend/src/services/firebaseService.ts
// Using relative import until TS path mapping for @/config resolves in tooling
import { auth } from '../config/firebase';
import {
  signInWithRedirect,
  GoogleAuthProvider,
  onAuthStateChanged,
  signOut,
  User
} from 'firebase/auth';
const googleProvider = new GoogleAuthProvider();
googleProvider.setCustomParameters({
  prompt: 'select_account'
});

export const firebaseService = {
  // Firebase Authentication
  signInWithGoogle: async () => {
    try {
      await signInWithRedirect(auth, googleProvider);
      return null;
    } catch (error) {
      console.error('Error signing in with Google:', error);
      throw error;
    }
  },
  
  signOut: async () => {
    try {
      await signOut(auth);
    } catch (error) {
      console.error('Error signing out:', error);
      throw error;
    }
  },
  
  getCurrentUser: (): Promise<User | null> => {
    return new Promise((resolve) => {
      const unsubscribe = onAuthStateChanged(auth, (user) => {
        unsubscribe();
        resolve(user);
      });
    });
  },
  
  getIdToken: async (): Promise<string | null> => {
    const user = auth.currentUser;
    if (!user) return null;
    try {
      return await user.getIdToken();
    } catch (error) {
      console.error('Error getting ID token:', error);
      return null;
    }
  }
};

========================================================================================
FILE: src/services/api.js
========================================================================================
import axios from 'axios';
import { auth } from '@/config/firebase';

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'https://learn.geaux.app',
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
  timeout: 10000, // 10 second timeout
  withCredentials: true // Enable sending cookies in cross-origin requests
});

// Add request interceptor for auth headers
api.interceptors.request.use(
  async (config) => {
    const user = auth.currentUser;
    if (user) {
      try {
        const token = await user.getIdToken(true); // Get a fresh token
        config.headers.Authorization = `Bearer ${token}`;
      } catch (error) {
        console.error("Error refreshing token:", error);
        localStorage.removeItem('token');
      }
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Add response interceptor with enhanced error handling
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Handle unauthorized errors and try token refresh
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const user = auth.currentUser;
        if (user) {
          const newToken = await user.getIdToken(true);
          localStorage.setItem('token', newToken);
          originalRequest.headers.Authorization = `Bearer ${newToken}`;
          return api(originalRequest);
        }
      } catch (refreshError) {
        console.error("Token refresh failed. Logging out...", refreshError);
        localStorage.removeItem('token');
        window.location.href = '/login'; // Redirect to login
      }
    }

    // Handle other error cases
    console.error('API Error:', {
      status: error.response?.status,
      data: error.response?.data,
      request: error.request,
      message: error.message
    });

    // Enhanced error handling
    let errorMessage = "An error occurred. Please try again.";
    switch (error.response?.status) {
      case 400:
        errorMessage = "Bad request. Please check your input.";
        break;
      case 403:
        errorMessage = "You don't have permission to perform this action.";
        break;
      case 404:
        errorMessage = "The requested resource was not found.";
        break;
      case 500:
        errorMessage = "Internal server error. Please try again later.";
        break;
      case 503:
        errorMessage = "Service unavailable. Please try again later.";
        break;
      default:
        errorMessage = `Error: ${error.message}`;
    }

    return Promise.reject(new Error(errorMessage));
  }
);

export default api;

========================================================================================
FILE: src/services/varkService.ts
========================================================================================
import { firestore as db } from '../config/firebase';
import { doc, setDoc, updateDoc, serverTimestamp } from 'firebase/firestore';

interface AssessmentResponse {
  assessmentId: string;
  initialMessage: string;
}

interface VARKResults {
  visual: number;
  auditory: number;
  readWrite: number;
  kinesthetic: number;
  primaryStyle: string;
}

interface UserResponse {
  message: string;
  nextQuestionIndex: number;
  currentQuestion: string;
  isComplete: boolean;
  results?: VARKResults;
}

export const startAssessment = async (userId: string): Promise<AssessmentResponse> => {
  const response = await fetch('/api/vark/start', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ userId }),
  });
  
  if (!response.ok) {
    throw new Error('Failed to start assessment');
  }
  
  return response.json();
};

export const sendUserResponse = async ({
  userId,
  assessmentId,
  message,
  questionIndex,
}: {
  userId: string;
  assessmentId: string;
  message: string;
  questionIndex: number;
}): Promise<UserResponse> => {
  const response = await fetch('/api/vark/respond', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      userId,
      assessmentId,
      message,
      questionIndex,
    }),
  });
  
  if (!response.ok) {
    throw new Error('Failed to process response');
  }
  
  return response.json();
};

export const saveAssessmentResults = async (
  userId: string, 
  results: VARKResults
): Promise<void> => {
  try {
    const userRef = doc(db, 'users', userId);
    const resultsRef = doc(db, 'varkResults', userId);
    
    // Update user document with primary learning style
    await updateDoc(userRef, {
      primaryLearningStyle: results.primaryStyle,
      updatedAt: serverTimestamp()
    });
    
    // Save detailed results
    await setDoc(resultsRef, {
      ...results,
      userId,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
  } catch (error) {
    console.error('Error saving results:', error);
    throw error;
  }
};

========================================================================================
FILE: src/services/cheshireService.ts
========================================================================================
import axios, { AxiosInstance } from 'axios';
import { auth } from '../config/firebase';

// Use environment variable if set, otherwise fall back to the production URL
const CHESHIRE_API_URL = import.meta.env.VITE_CHESHIRE_API_URL || 'https://cheshire.geaux.app';
const CHESHIRE_DEBUG = import.meta.env.VITE_CHESHIRE_DEBUG === 'true';

// Create axios instance with default configuration
const cheshireAxios: AxiosInstance = axios.create({
  baseURL: CHESHIRE_API_URL,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  },
  withCredentials: true,
  timeout: 30000
});

// Add authentication interceptor
cheshireAxios.interceptors.request.use(async (config) => {
  try {
    const user = auth.currentUser;
    if (user) {
      const token = await user.getIdToken();
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  } catch (error) {
    console.error('Auth interceptor error:', error);
    return Promise.reject(error);
  }
});

// Add response interceptor for better error handling
cheshireAxios.interceptors.response.use(
  (response) => response,
  (error) => {
    if (CHESHIRE_DEBUG) {
      console.error('Cheshire API Error:', {
        message: error.message,
        code: error.code,
        status: error.response?.status,
        data: error.response?.data,
        config: {
          url: error.config?.url,
          method: error.config?.method,
          headers: error.config?.headers
        }
      });
    }

    if (error.code === 'ERR_NETWORK') {
      console.error('Network error - Unable to connect to Cheshire API:', error);
      console.error('Please ensure the TIPI container is running and accessible at:', CHESHIRE_API_URL);
    }
    return Promise.reject(error);
  }
);

interface CheshireResponse {
  text: string;
  response: string;
  memories?: Array<{
    metadata?: {
      learning_style?: string;
    };
  }>;
}

interface CheshireUser {
  username: string;
  permissions: {
    CONVERSATION: string[];
    MEMORY: string[];
    STATIC: string[];
    STATUS: string[];
  };
}

interface AuthResponse {
  access_token: string;
  token_type: string;
}

interface CheshireError {
  message: string;
  code?: string;
  response?: {
    status: number;
    data: unknown;
  };
  config?: {
    url: string;
    method: string;
    headers: Record<string, string>;
  };
}

export class CheshireService {
  private static async getAuthHeaders() {
    const user = auth.currentUser;
    if (!user) {
      throw new Error('Authentication required');
    }
    const token = await user.getIdToken();
    return {
      Authorization: `Bearer ${token}`
    };
  }

  private static async getFirebaseToken(): Promise<string | null> {
    try {
      const user = auth.currentUser;
      if (!user) {
        throw new Error('No user logged in');
      }
      return await user.getIdToken();
    } catch (error) {
      console.error('Error getting Firebase token:', error);
      return null;
    }
  }

  static async checkTipiHealth(): Promise<{ status: string; version: string }> {
    try {
      const response = await cheshireAxios.get('/');
      return {
        status: 'healthy',
        version: response.data.version || 'unknown'
      };
    } catch (error) {
      const err = error as CheshireError;
      console.error('TIPI health check failed:', err);
      if (err.code === 'ERR_NETWORK') {
        throw new Error('TIPI container is not accessible. Please ensure it is running.');
      }
      throw err;
    }
  }

  static async initialize(): Promise<void> {
    try {
      // Check TIPI container health
      await this.checkTipiHealth();
      
      console.log('✅ Cheshire Cat service initialized successfully');
    } catch (error) {
      console.error('❌ Failed to initialize Cheshire Cat service:', error);
      throw error;
    }
  }

  static async checkConnection(): Promise<boolean> {
    try {
      const headers = await this.getAuthHeaders();
      await cheshireAxios.get('/', { headers });
      return true;
    } catch (error) {
      console.error('Cheshire API Connection Error:', error);
      return false;
    }
  }

  static async sendChatMessage(message: string, userId: string, chatId: string) {
    try {
      const headers = await this.getAuthHeaders();
      const response = await cheshireAxios.post<CheshireResponse>(
        '/message',
        { text: message },
        { headers }
      );
      
      return {
        data: response.data.response,
        memories: response.data.memories
      };
    } catch (error) {
      console.error('Error sending chat message:', error);
      throw this.getErrorMessage(error as CheshireError);
    }
  }

  static async createCheshireUser(firebaseUid: string, email: string): Promise<void> {
    try {
      const headers = await this.getAuthHeaders();
      const payload: CheshireUser = {
        username: email,
        permissions: {
          CONVERSATION: ["WRITE", "EDIT", "LIST", "READ", "DELETE"],
          MEMORY: ["READ", "LIST"],
          STATIC: ["READ"],
          STATUS: ["READ"]
        }
      };

      await cheshireAxios.post('/users/', payload, { headers });
    } catch (error) {
      console.error('Error creating Cheshire user:', error);
      throw this.getErrorMessage(error as CheshireError);
    }
  }

  static getErrorMessage(error: CheshireError): string {
    if (error.message === 'Authentication required') {
      return "Please log in to continue.";
    }
    if (error.message === 'Failed to obtain Cheshire auth token') {
      return "Unable to connect to the chat service. Please try again later.";
    }
    if (error.code === 'ECONNABORTED') {
      return "The request timed out. Please try again.";
    }
    if (error.code === 'ERR_NETWORK') {
      if (error.message.includes('CORS')) {
        return "Unable to connect to the chat service due to CORS restrictions. Please contact support.";
      }
      return "Network error - Unable to connect to the chat service. Please check your connection and try again.";
    }
    if (error.response?.status === 401) {
      return "Your session has expired. Please try again.";
    }
    if (error.response?.status === 403) {
      return "You don't have permission to perform this action.";
    }
    if (error.response?.status === 404) {
      return "The chat service is not available. Please check if the service is running.";
    }
    return "Sorry, I'm having trouble connecting to the chat service. Please try again later.";
  }
}

========================================================================================
FILE: src/services/openai.js
========================================================================================

import axios from 'axios';

const openaiClient = axios.create({
  baseURL: 'https://api.openai.com/v1',
  headers: {
    'Authorization': `Bearer ${import.meta.env.VITE_OPENAI_API_KEY}`,
    'Content-Type': 'application/json'
  }
});

export default openaiClient;

========================================================================================
FILE: src/config/firebase.ts
========================================================================================
// File: /src/config/firebase.ts
// Description: Centralized Firebase initialization & singleton exports (app, auth, firestore)
// Author: GitHub Copilot
// Created: 2025-09-07

import { initializeApp, getApps, getApp } from 'firebase/app';
import {
  browserLocalPersistence,
  browserSessionPersistence,
  getAuth,
  inMemoryPersistence,
  setPersistence
} from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

// Validate required Firebase config (warn only in dev so UI still mounts)
function validateFirebaseConfig() {
  const requiredVars = [
    'VITE_FIREBASE_API_KEY',
    'VITE_FIREBASE_AUTH_DOMAIN',
    'VITE_FIREBASE_PROJECT_ID',
    'VITE_FIREBASE_STORAGE_BUCKET',
    'VITE_FIREBASE_MESSAGING_SENDER_ID',
    'VITE_FIREBASE_APP_ID'
  ];
  const missing = requiredVars.filter(v => !import.meta.env[v as keyof ImportMetaEnv]);
  if (missing.length) {
    // eslint-disable-next-line no-console
    console.warn('[firebase] Missing env vars (continuing for dev):', missing.join(', '));
  }
}

validateFirebaseConfig();

export const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
  measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID,
  databaseURL: import.meta.env.VITE_FIREBASE_DATABASE_URL,
  vapidKey: import.meta.env.VITE_FIREBASE_VAPID_KEY
};

// Ensure single app instance
export const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
export const auth = getAuth(app);
const withTimeout = <T,>(promise: Promise<T>, ms: number, label: string): Promise<T> =>
  Promise.race([
    promise,
    new Promise<T>((_, reject) => {
      setTimeout(() => reject(new Error(`${label} timeout`)), ms);
    })
  ]);

const DEV_PERSISTENCE_TIMEOUT_MS = 5000;

export const authInit = (async () => {
  if (!import.meta.env.DEV) {
    try {
      await setPersistence(auth, browserLocalPersistence);
    } catch {
      // ignore in production
    }
    return;
  }

  console.debug('[firebase] setPersistence start');
  try {
    await withTimeout(
      setPersistence(auth, browserLocalPersistence),
      DEV_PERSISTENCE_TIMEOUT_MS,
      'local persistence'
    );
    console.debug('[firebase] persistence=local');
    return;
  } catch (error) {
    console.warn('[firebase] local persistence failed:', error);
  }

  try {
    await withTimeout(
      setPersistence(auth, browserSessionPersistence),
      DEV_PERSISTENCE_TIMEOUT_MS,
      'session persistence'
    );
    console.debug('[firebase] persistence=session');
    return;
  } catch (error) {
    console.warn('[firebase] session persistence failed:', error);
  }

  try {
    await withTimeout(
      setPersistence(auth, inMemoryPersistence),
      DEV_PERSISTENCE_TIMEOUT_MS,
      'memory persistence'
    );
    console.debug('[firebase] persistence=memory');
  } catch (error) {
    console.warn('[firebase] persistence disabled (continuing):', error);
  }
})();
export const firestore = getFirestore(app);

console.info('[firebase] projectId', firebaseConfig.projectId ?? 'unknown');

if (import.meta.env.DEV) {
  console.debug('[firebase] app name', app.name);
  console.debug('[firebase] auth instance', auth.app.name);
}

// Default export kept for backward compatibility (legacy imports)
export default app;

========================================================================================
FILE: src/firebase/auth-service.ts
========================================================================================
import { GoogleAuthProvider, signInWithPopup, signOut as firebaseSignOut, Auth, User } from "firebase/auth";
import { auth } from './config';

export class AuthService {
  private provider: GoogleAuthProvider;
  private initialized: boolean = false;
  private popupOpen: boolean = false;
  private _auth: Auth;

  constructor() {
    this.provider = new GoogleAuthProvider();
    this.provider.setCustomParameters({
      prompt: 'select_account',
      scope: 'email profile'
    });
    this._auth = auth;
  }

  get auth(): Auth {
    return this._auth;
  }

  private async ensureInitialized() {
    if (!this.initialized) {
      await new Promise<void>((resolve) => {
        const unsubscribe = this._auth.onAuthStateChanged(() => {
          unsubscribe();
          this.initialized = true;
          resolve();
        });
      });
    }
  }

  private async refreshUserToken(user: User): Promise<string> {
    try {
      const token = await user.getIdToken(true);
      return token;
    } catch (error: any) {
      console.error('Token refresh error:', error);
      throw new Error(error.message || 'Failed to refresh authentication token');
    }
  }

  async signInWithGoogle() {
    try {
      if (this.popupOpen) {
        throw new Error('Authentication popup is already open');
      }

      await this.ensureInitialized();
      this.popupOpen = true;

      const result = await signInWithPopup(this._auth, this.provider);
      const token = await this.refreshUserToken(result.user);
      
      // Store token in a secure way
      if (window.isSecureContext) {
        sessionStorage.setItem('authToken', token);
      }
      
      return result;
    } catch (error: any) {
      console.error('Google sign-in error:', error);
      if (error.code === 'auth/popup-closed-by-user') {
        throw new Error('Sign-in cancelled by user');
      } else if (error.code === 'auth/popup-blocked') {
        throw new Error('Sign-in popup was blocked. Please allow popups for this site');
      }
      throw new Error(error.message || 'Failed to sign in with Google');
    } finally {
      this.popupOpen = false;
    }
  }

  async signOut() {
    try {
      await this.ensureInitialized();
      if (window.isSecureContext) {
        sessionStorage.removeItem('authToken');
      }
      await firebaseSignOut(this._auth);
    } catch (error: any) {
      console.error('Sign out error:', error);
      throw new Error(error.message || 'Failed to sign out');
    }
  }

  async refreshToken(): Promise<string | null> {
    try {
      await this.ensureInitialized();
      const currentUser = this._auth.currentUser;
      
      if (!currentUser) {
        return null;
      }

      const token = await this.refreshUserToken(currentUser);
      
      if (window.isSecureContext) {
        sessionStorage.setItem('authToken', token);
      }
      
      return token;
    } catch (error: any) {
      console.error('Token refresh error:', error);
      throw new Error(error.message || 'Failed to refresh authentication token');
    }
  }

  getCurrentToken(): string | null {
    if (!window.isSecureContext) {
      return null;
    }
    return sessionStorage.getItem('authToken');
  }
}

========================================================================================
FILE: src/firebase/messaging-utils.ts
========================================================================================
// File: /src/firebase/messaging-utils.ts
// Description: Firebase messaging utilities with proper TypeScript support and error handling
// Author: GitHub Copilot
// Created: 2024-02-17

import { getToken, getMessaging } from 'firebase/messaging';
import { app } from './config';

const VAPID_KEY = 'YOUR_VAPID_KEY_HERE'; // TODO: Replace with actual VAPID key

export interface ServiceWorkerRegistrationResult {
  success: boolean;
  token?: string;
  error?: string;
}

export async function registerMessagingWorker(): Promise<ServiceWorkerRegistrationResult> {
  if (!window.isSecureContext) {
    return {
      success: false,
      error: 'Service Worker registration requires a secure context (HTTPS or localhost)'
    };
  }

  if (!('serviceWorker' in navigator)) {
    return {
      success: false,
      error: 'Service Worker is not supported in this browser'
    };
  }

  try {
    const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js', {
      scope: '/',
      type: 'module'
    });

    const messaging = getMessaging(app);
    const token = await getToken(messaging, {
      vapidKey: VAPID_KEY,
      serviceWorkerRegistration: registration
    });

    if (!token) {
      return {
        success: false,
        error: 'Failed to get messaging token'
      };
    }

    return {
      success: true,
      token
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to register service worker'
    };
  }
}

export async function unregisterMessagingWorker(): Promise<void> {
  if ('serviceWorker' in navigator) {
    const registrations = await navigator.serviceWorker.getRegistrations();
    for (const registration of registrations) {
      await registration.unregister();
    }
  }
}

========================================================================================
FILE: src/firebase/firebase-messaging-sw.ts
========================================================================================
// File: /src/firebase/firebase-messaging-sw.ts
// Description: Firebase service worker configuration for handling background messages and notifications
// Author: GitHub Copilot
// Created: 2024-02-17

/// <reference lib="webworker" />

import { initializeApp } from 'firebase/app';
import { getMessaging, onBackgroundMessage, MessagePayload } from 'firebase/messaging/sw';
import { firebaseConfig } from '../config/firebase';

declare const self: ServiceWorkerGlobalScope;

// Initialize Firebase in the service worker
const app = initializeApp(firebaseConfig);
const messaging = getMessaging(app);

// Handle background messages
onBackgroundMessage(messaging, (payload: MessagePayload) => {
  console.log('[Firebase Messaging SW] Received background message:', payload);

  // Customize notification here
  const notificationTitle = payload.notification?.title || 'New Message';
  const notificationOptions: NotificationOptions = {
    body: payload.notification?.body,
    icon: '/images/logo.svg',
    badge: '/images/logo.svg',
    tag: payload.collapseKey || 'default',
    data: payload.data,
    requireInteraction: true,
    silent: false
  };

  return self.registration.showNotification(notificationTitle, notificationOptions);
});

// Handle notification click
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  // Add custom click handling here
  const clickAction = event.notification.data?.clickAction || '/';
  
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((windowClients) => {
        // If a window client is already open, focus it
        for (const client of windowClients) {
          if (client.url === clickAction && 'focus' in client) {
            return client.focus();
          }
        }
        // Otherwise open a new window
        if (self.clients.openWindow) {
          return self.clients.openWindow(clickAction);
        }
      })
  );
});

// Handle service worker activation
self.addEventListener('activate', (event) => {
  event.waitUntil(
    Promise.all([
      // Take control of all pages immediately
      self.clients.claim(),
      // Optional: Clean up old caches here if needed
    ])
  );
});

========================================================================================
FILE: src/firebase/auth-service-worker.ts
========================================================================================
import { enableIndexedDbPersistence, type FirestoreSettings } from 'firebase/firestore';
import { firestore } from './config';

interface ServiceWorkerError extends Error {
  name: string;
  code?: string;
}

interface AuthServiceWorkerMessage {
  type: string;
  status?: number;
  ok?: boolean;
  fallbackToRedirect?: boolean;
  error?: string;
  secure?: boolean;
}

interface ServiceWorkerRegistrationResult {
  success: boolean;
  isSecure: boolean;
  supportsServiceWorker: boolean;
  error?: string;
}

const SW_TIMEOUT = Number(import.meta.env.VITE_SERVICE_WORKER_TIMEOUT) || 10000;
const MAX_RETRIES = Number(import.meta.env.VITE_MAX_AUTH_RETRIES) || 3;

const isSecureContext = (): boolean => {
  return window.isSecureContext && (
    window.location.protocol === 'https:' || 
    window.location.hostname === 'localhost' ||
    window.location.hostname === '127.0.0.1'
  );
};

let serviceWorkerRegistration: ServiceWorkerRegistration | null = null;
let retryCount = 0;

const registerWithRetry = async (): Promise<ServiceWorkerRegistration> => {
  try {
    const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js', {
      scope: '/__/auth',
      type: 'module',
      updateViaCache: 'none'
    });
    return registration;
  } catch (error) {
    if (retryCount < MAX_RETRIES) {
      retryCount++;
      await new Promise(resolve => setTimeout(resolve, 1000));
      return registerWithRetry();
    }
    throw error;
  }
};

export const registerAuthServiceWorker = async (): Promise<ServiceWorkerRegistrationResult> => {
  if (!('serviceWorker' in navigator)) {
    return {
      success: false,
      isSecure: false,
      supportsServiceWorker: false,
      error: 'Service workers are not supported in this browser'
    };
  }

  if (!isSecureContext()) {
    return {
      success: false,
      isSecure: false,
      supportsServiceWorker: true,
      error: 'Secure context required for authentication'
    };
  }

  try {
    const registrations = await navigator.serviceWorker.getRegistrations();
    await Promise.all(registrations.map(registration => registration.unregister()));

    serviceWorkerRegistration = await registerWithRetry();

    const activationPromise = new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Service worker activation timeout'));
      }, SW_TIMEOUT);

      if (serviceWorkerRegistration?.active) {
        clearTimeout(timeout);
        resolve();
        return;
      }

      serviceWorkerRegistration?.addEventListener('activate', () => {
        clearTimeout(timeout);
        resolve();
      });
    });

    await activationPromise;

    return {
      success: true,
      isSecure: isSecureContext(),
      supportsServiceWorker: true
    };

  } catch (error) {
    console.error('Service worker registration failed:', error);
    return {
      success: false,
      isSecure: isSecureContext(),
      supportsServiceWorker: true,
      error: error instanceof Error ? error.message : 'Service worker registration failed'
    };
  }
};

export const initAuthServiceWorker = async (): Promise<boolean> => {
  const result = await registerAuthServiceWorker();
  
  window.dispatchEvent(new CustomEvent('firebase-auth-worker-status', { 
    detail: result 
  }));

  if (!result.success) {
    console.warn('Auth service worker initialization failed:', result.error);
    return false;
  }

  // Initialize Firestore persistence after successful service worker registration
  try {
    const settings: FirestoreSettings = {
      cacheSizeBytes: 50000000, // 50 MB
    };
    
    await enableIndexedDbPersistence(db);
    
    return true;
  } catch (error) {
    console.error('Failed to enable persistence:', error);
    return false;
  }
};

function handleServiceWorkerMessage(event: MessageEvent<AuthServiceWorkerMessage>) {
  const { type, status, ok, fallbackToRedirect, error, secure } = event.data;

  const dispatch = (eventName: string, detail: any) => {
    window.dispatchEvent(new CustomEvent(eventName, { detail }));
  };

  switch (type) {
    case 'FIREBASE_SERVICE_WORKER_READY':
      console.debug('Firebase auth service worker ready');
      dispatch('firebase-auth-worker-ready', { secure });
      break;
      
    case 'FIREBASE_AUTH_POPUP_READY':
      console.debug('Firebase auth popup ready');
      dispatch('firebase-auth-popup-ready', { secure });
      break;
      
    case 'FIREBASE_AUTH_POPUP_ERROR':
      if (fallbackToRedirect && import.meta.env.VITE_AUTH_POPUP_FALLBACK === 'true') {
        console.warn('Popup authentication failed, falling back to redirect method');
      }
      dispatch('firebase-auth-error', { error, fallbackToRedirect });
      break;
      
    case 'AUTH_RESPONSE':
      if (!ok) {
        console.error('Authentication response error:', status);
        dispatch('firebase-auth-error', { status, error });
      } else {
        dispatch('firebase-auth-success', { status });
      }
      break;
      
    case 'SECURE_CONTEXT_CHECK':
      if (!secure) {
        console.warn('Authentication requires a secure context (HTTPS)');
        dispatch('firebase-auth-security', { secure: false });
      }
      break;
  }
}

navigator.serviceWorker?.addEventListener('message', handleServiceWorkerMessage);

export default initAuthServiceWorker;

========================================================================================
FILE: src/types/auth.ts
========================================================================================
import { User, UserCredential } from 'firebase/auth';

export interface AuthError {
  code?: string;
  message: string;
}

export interface AuthContextType {
  currentUser: User | null;
  user: User | null;
  loading: boolean;
  isLoading: boolean;
  isAuthReady: boolean;
  error: string | null;
  login: (email: string, password: string) => Promise<UserCredential>;
  loginWithGoogle: () => Promise<User | null>;
  signup: (email: string, password: string) => Promise<UserCredential>;
  logout: () => Promise<void>;
  clearError: () => void;
}

export interface Student {
  id: string;
  name: string;
  grade: string;
  parentId: string;
  hasTakenAssessment: boolean;
  createdAt: string;
  updatedAt: string;
  learningStyle?: string;
  assessmentResults?: object;
}

export interface Parent {
  id: string;
  uid: string;
  email: string;
  displayName: string;
  phone?: string;
  students: string[];
  createdAt: string;
  updatedAt: string;
}

export interface AuthRouteProps {
  children: React.ReactNode;
}

export interface PrivateRouteProps {
  children: React.ReactNode;
}

declare global {
  interface WindowEventMap {
    'firebase-auth-worker-status': CustomEvent<{
      success: boolean;
      isSecure: boolean;
      supportsServiceWorker: boolean;
      error?: string;
    }>;
    'firebase-auth-error': CustomEvent<{
      error: string;
      fallbackToRedirect?: boolean;
      status?: number;
    }>;
    'firebase-auth-popup-ready': CustomEvent<{
      secure: boolean;
    }>;
    'firebase-auth-success': CustomEvent<{
      status: number;
    }>;
    'firebase-auth-security': CustomEvent<{
      secure: boolean;
    }>;
  }
}

export {};

========================================================================================
FILE: src/types/profiles.ts
========================================================================================
// Base Types
export interface BaseProfile {
    uid: string;
    email: string;
    displayName: string;
    createdAt: string;
    updatedAt: string;
}

// Parent Profile Types
export interface Parent extends BaseProfile {
    phone?: string;
    students: string[];
}

// Student Profile Types
export interface Student {
    id: string;
    parentId: string;
    name: string;
    grade: string;
    learningStyle?: LearningStyle;
    hasTakenAssessment: boolean;
    assessmentStatus?: string;
    createdAt: string;
    updatedAt: string;
    recommendedActivities?: string[];
    progress?: StudentProgress[];
    assessmentResults?: AssessmentResult[];
}

// Progress Types
export interface StudentProgress {
    courseId: string;
    completed: number;
    total: number;
    lastAccessed: string;
}

// Assessment Types
export interface AssessmentResult {
    date: string;
    score: number;
    subject: string;
    details: Record<string, unknown>;
}

// Learning Style Types
export interface LearningStyle {
    type: 'visual' | 'auditory' | 'kinesthetic' | 'reading/writing';
    strengths: string[];
    recommendations: string[];
}

========================================================================================
FILE: src/types/student.ts
========================================================================================
export interface Student {
  id: string;
  name: string;
  grade?: string;
  age?: number;
  learningStyle?: string;
  hasTakenAssessment: boolean;
  progress?: Array<{
    id: string;
    type: string;
    name: string;
    date: string;
  }>;
  recommendedActivities?: string[];
  createdAt?: string;
  updatedAt?: string;
  parentId: string;
}

========================================================================================
FILE: src/models/Student.ts
========================================================================================
// File: /src/models/Student.ts
// Description: MongoDB schema model for students
// Created: 2025-02-25

import mongoose, { Schema, Document } from 'mongoose';

export interface IStudent extends Document {
  uid: string;
  firstName: string;
  lastName: string;
  grade: string;
  parentId: string;
  learningStyle?: {
    visual: number;
    auditory: number;
    reading: number;
    kinesthetic: number;
    primary: 'visual' | 'auditory' | 'reading' | 'kinesthetic';
  };
  createdAt: Date;
  updatedAt: Date;
}

const StudentSchema: Schema = new Schema(
  {
    uid: { type: String, required: true, unique: true },
    firstName: { type: String, required: true },
    lastName: { type: String, required: true },
    grade: { type: String, required: true },
    parentId: { type: String, required: true, ref: 'Parent' },
    learningStyle: {
      visual: { type: Number, min: 0, max: 100, default: 0 },
      auditory: { type: Number, min: 0, max: 100, default: 0 },
      reading: { type: Number, min: 0, max: 100, default: 0 },
      kinesthetic: { type: Number, min: 0, max: 100, default: 0 },
      primary: { 
        type: String, 
        enum: ['visual', 'auditory', 'reading', 'kinesthetic'],
      }
    }
  },
  {
    timestamps: true,
  }
);

export default mongoose.models.Student || mongoose.model<IStudent>('Student', StudentSchema);

========================================================================================
FILE: src/models/Parent.ts
========================================================================================
// File: /src/models/Parent.ts
// Description: MongoDB schema model for parents
// Created: 2025-02-25

import mongoose, { Schema, Document } from 'mongoose';
import { IUser } from './User';

export interface IParent extends Document {
  uid: string;
  firstName: string;
  lastName: string;
  email: string;
  phone?: string;
  createdAt: Date;
  updatedAt: Date;
  students: string[]; // References to student IDs
}

const ParentSchema: Schema = new Schema(
  {
    uid: { type: String, required: true, unique: true, ref: 'User' },
    firstName: { type: String, required: true },
    lastName: { type: String, required: true },
    email: { type: String, required: true },
    phone: { type: String },
    students: [{ type: String, ref: 'Student' }],
  },
  {
    timestamps: true,
  }
);

export default mongoose.models.Parent || mongoose.model<IParent>('Parent', ParentSchema);

========================================================================================
FILE: src/models/Assessment.ts
========================================================================================
// File: /src/models/Assessment.ts
// Description: MongoDB schema model for assessments
// Created: 2025-02-25

import mongoose, { Schema, Document } from 'mongoose';

export interface IAssessment extends Document {
  studentId: string;
  assessmentType: string;
  score: number;
  details?: any;
  timestamp: Date;
  createdAt: Date;
  updatedAt: Date;
}

const AssessmentSchema: Schema = new Schema(
  {
    studentId: { type: String, required: true, ref: 'Student' },
    assessmentType: { type: String, required: true },
    score: { type: Number, required: true },
    details: { type: Schema.Types.Mixed },
    timestamp: { type: Date, default: Date.now },
  },
  {
    timestamps: true,
  }
);

// Create compound index for efficient queries by student and assessment type
AssessmentSchema.index({ studentId: 1, assessmentType: 1 });

export default mongoose.models.Assessment || mongoose.model<IAssessment>('Assessment', AssessmentSchema);

========================================================================================
FILE: src/components/common/LoadingSpinner.tsx
========================================================================================
import React from 'react';
import styled from 'styled-components';

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: rgba(255, 255, 255, 0.8);
`;

const SpinnerElement = styled.div`
  width: 50px;
  height: 50px;
  border: 5px solid #f3f3f3;
  border-top: 5px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
`;

const LoadingSpinner: React.FC = () => {
  return (
    <LoadingContainer>
      <SpinnerElement />
    </LoadingContainer>
  );
};

export default LoadingSpinner;

========================================================================================
FILE: src/components/common/Modal.tsx
========================================================================================
import React, { useEffect } from 'react';
import styled from 'styled-components';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
}

const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {
  useEffect(() => {
    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
    };
    window.addEventListener('keydown', handleEsc);
    return () => window.removeEventListener('keydown', handleEsc);
  }, [onClose]);

  if (!isOpen) return null;

  return (
    <Overlay onClick={onClose}>
      <Content onClick={(e: React.MouseEvent) => e.stopPropagation()}>
        <Header>
          <Title>{title}</Title>
          <CloseButton onClick={onClose}>&times;</CloseButton>
        </Header>
        <Body>{children}</Body>
      </Content>
    </Overlay>
  );
};

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
`;

const Content = styled.div`
  background: ${({ theme }) => theme.palette.background.paper};
  border-radius: 8px;
  padding: ${({ theme }) => theme.spacing.lg};
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  position: relative;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding-bottom: ${({ theme }) => theme.spacing.sm};
  border-bottom: 1px solid ${({ theme }) => theme.palette.divider};
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.palette.text.primary};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  padding: ${({ theme }) => theme.spacing.xs};
  color: ${({ theme }) => theme.palette.text.secondary};
  transition: color 0.2s ease;

  &:hover {
    color: ${({ theme }) => theme.palette.text.primary};
  }
`;

const Body = styled.div`
  color: ${({ theme }) => theme.palette.text.primary};
`;

export default Modal;

========================================================================================
FILE: src/components/common/Toast.tsx
========================================================================================
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';
import styled, { css } from 'styled-components';

type ToastType = 'info' | 'success' | 'warning' | 'error';

interface ToastProps {
  message: string;
  type?: ToastType;
  duration?: number;
  onClose?: () => void;
}

const Toast: React.FC<ToastProps> = ({ message, type = 'info', duration = 3000, onClose }) => {
  const [isVisible, setIsVisible] = useState(true);

  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(false);
      onClose?.();
    }, duration);

    return () => clearTimeout(timer);
  }, [duration, onClose]);

  if (!isVisible) return null;

  return (
    <ToastContainer $type={type}>
      <p>{message}</p>
    </ToastContainer>
  );
};

const showToast = (props: ToastProps): void => {
  const toastElement = document.createElement('div');
  document.body.appendChild(toastElement);
  
  const onClose = () => {
    document.body.removeChild(toastElement);
    props.onClose?.();
  };
  
  const toastComponent = React.createElement(Toast, { ...props, onClose });
  ReactDOM.render(toastComponent, toastElement);
};

const getToastColor = (type: ToastType) => {
  switch (type) {
    case 'success':
      return css`
        background-color: ${({ theme }) => theme.palette.success?.main || '#2ECC71'};
        color: white;
      `;
    case 'warning':
      return css`
        background-color: ${({ theme }) => theme.palette.warning?.main || '#F1C40F'};
        color: white;
      `;
    case 'error':
      return css`
        background-color: ${({ theme }) => theme.palette.error?.main || '#E74C3C'};
        color: white;
      `;
    default:
      return css`
        background-color: ${({ theme }) => theme.palette.info?.main || '#3498DB'};
        color: white;
      `;
  }
};

const ToastContainer = styled.div<{ $type: ToastType }>`
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: 4px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  z-index: 1000;
  animation: slideIn 0.3s ease-out;
  ${props => getToastColor(props.$type)}

  p {
    margin: 0;
  }

  @keyframes slideIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
`;

export default Toast;

========================================================================================
FILE: src/components/common/Button.tsx
========================================================================================
import React from 'react';
import { Link } from 'react-router-dom';
import styled from 'styled-components';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  to?: string;
  $variant?: 'primary' | 'secondary';
  size?: 'small' | 'medium' | 'large';
  children: React.ReactNode;
}

const Button: React.FC<ButtonProps> = ({ to, children, $variant = 'primary', size = 'medium', ...props }) => {
  const className = `btn btn-${$variant} btn-${size}`;
  
  if (to) {
    return (
      <Link to={to} className={className}>
        {children}
      </Link>
    );
  }

  return (
    <StyledButton className={className} {...props}>
      {children}
    </StyledButton>
  );
};

const StyledButton = styled.button`
  border: none;
  cursor: pointer;
  font-family: inherit;
  font-size: inherit;
  
  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  &.btn-small {
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
  }

  &.btn-medium {
    padding: 0.75rem 1.5rem;
    font-size: 1rem;
  }

  &.btn-large {
    padding: 1rem 2rem;
    font-size: 1.125rem;
  }
`;

export default Button;

========================================================================================
FILE: src/components/VARKAssessment/TypingIndicator.tsx
========================================================================================
import React from 'react';
import { motion } from 'framer-motion';

const TypingIndicator: React.FC = () => {
  return (
    <div className="flex items-center gap-2 p-3 max-w-[100px] bg-white rounded-xl shadow-md mb-4">
      {[0, 1, 2].map((i) => (
        <motion.div
          key={i}
          initial={{ y: 0 }}
          animate={{ y: [-2, 2, -2] }}
          transition={{
            duration: 0.6,
            repeat: Infinity,
            delay: i * 0.2,
          }}
          className="w-2 h-2 bg-blue-600 rounded-full"
        />
      ))}
    </div>
  );
};

export default TypingIndicator;

========================================================================================
FILE: src/components/chat/TestChat.tsx
========================================================================================
import React, { useEffect, useState } from 'react';
import styled from 'styled-components';
import { CheshireService } from '../../services/cheshireService';
import { useAuth } from '../../contexts/AuthContext';

const TestChat: React.FC = () => {
  const [connectionStatus, setConnectionStatus] = useState<string>('Checking connection...');
  const [testMessage, setTestMessage] = useState<string>('');
  const [response, setResponse] = useState<string>('');
  const [error, setError] = useState<string>('');
  const { currentUser } = useAuth();

  useEffect(() => {
    checkConnection();
  }, []);

  const checkConnection = async () => {
    try {
      const isConnected = await CheshireService.checkConnection();
      setConnectionStatus(isConnected ? 'Connected ✅' : 'Not connected ❌');
    } catch (error) {
      setConnectionStatus('Connection failed ❌');
      setError(CheshireService.getErrorMessage(error));
    }
  };

  const handleTestMessage = async () => {
    if (!testMessage.trim() || !currentUser?.uid) return;

    try {
      setError('');
      const result = await CheshireService.sendChatMessage(
        testMessage,
        currentUser.uid,
        'test'
      );
      setResponse(result.data);
      if (result.memories?.length) {
        console.log('Memories received:', result.memories);
      }
    } catch (error) {
      setError(CheshireService.getErrorMessage(error));
    }
  };

  return (
    <TestContainer>
      <TestCard>
        <h2>Cheshire Service Test</h2>
        
        <StatusSection>
          <h3>Connection Status:</h3>
          <StatusText>{connectionStatus}</StatusText>
          <RefreshButton onClick={checkConnection}>
            Refresh Connection
          </RefreshButton>
        </StatusSection>

        {error && <ErrorMessage>{error}</ErrorMessage>}

        <TestSection>
          <h3>Send Test Message:</h3>
          <TestInput
            value={testMessage}
            onChange={(e) => setTestMessage(e.target.value)}
            placeholder="Type a test message..."
          />
          <SendButton 
            onClick={handleTestMessage}
            disabled={!testMessage.trim() || !currentUser}
          >
            Send Message
          </SendButton>
        </TestSection>

        {response && (
          <ResponseSection>
            <h3>Response:</h3>
            <ResponseText>{response}</ResponseText>
          </ResponseSection>
        )}
      </TestCard>
    </TestContainer>
  );
};

const TestContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  padding: 1rem;
  background-color: var(--background);
`;

const TestCard = styled.div`
  background: white;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  width: 100%;
  max-width: 600px;

  h2 {
    text-align: center;
    margin-bottom: 1.5rem;
    color: var(--primary-color);
  }

  h3 {
    margin-bottom: 1rem;
    color: var(--text-color);
  }
`;

const StatusSection = styled.div`
  margin-bottom: 2rem;
  padding: 1rem;
  background-color: #f8f9fa;
  border-radius: 4px;
`;

const StatusText = styled.div`
  font-size: 1.1rem;
  margin-bottom: 1rem;
`;

const TestSection = styled.div`
  margin-bottom: 2rem;
`;

const TestInput = styled.textarea`
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-bottom: 1rem;
  min-height: 100px;
  resize: vertical;

  &:focus {
    outline: none;
    border-color: var(--primary-color);
  }
`;

const ResponseSection = styled.div`
  margin-top: 2rem;
  padding: 1rem;
  background-color: #f8f9fa;
  border-radius: 4px;
`;

const ResponseText = styled.div`
  white-space: pre-wrap;
  font-family: monospace;
  padding: 1rem;
  background-color: white;
  border: 1px solid #ddd;
  border-radius: 4px;
`;

const Button = styled.button`
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }
`;

const RefreshButton = styled(Button)`
  background-color: #6c757d;
  color: white;

  &:hover:not(:disabled) {
    background-color: #5a6268;
  }
`;

const SendButton = styled(Button)`
  background-color: var(--primary-color);
  color: white;
  width: 100%;

  &:hover:not(:disabled) {
    background-color: var(--primary-dark);
  }
`;

const ErrorMessage = styled.div`
  color: #dc2626;
  background-color: #fee2e2;
  padding: 0.75rem;
  border-radius: 4px;
  margin-bottom: 1rem;
  font-size: 0.875rem;
`;

export default TestChat;

========================================================================================
FILE: src/components/common/Card.tsx
========================================================================================
import React, { forwardRef } from 'react';
import styled from 'styled-components';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { IconProp } from '@fortawesome/fontawesome-svg-core';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  icon?: IconProp | string;
  title?: string;
  description?: string | string[];
  className?: string;
  onClick?: () => void;
}

const Card = forwardRef<HTMLDivElement, CardProps>(({
  icon,
  title,
  description,
  children,
  className,
  onClick,
  ...props
}, ref) => {
  const isImagePath = typeof icon === 'string' && (icon.startsWith('/') || icon.startsWith('http'));
  
  return (
    <StyledCard 
      ref={ref}
      className={className} 
      onClick={onClick}
      role={onClick ? 'button' : undefined}
      tabIndex={onClick ? 0 : undefined}
      {...props}
    >
      {icon && (
        <IconContainer>
          {isImagePath ? (
            <img 
              src={icon} 
              alt={title || 'Card icon'}
              crossOrigin={icon.startsWith('http') ? "anonymous" : undefined}
            />
          ) : (
            typeof icon === 'object' && <FontAwesomeIcon icon={icon} />
          )}
        </IconContainer>
      )}
      {title && <CardTitle>{title}</CardTitle>}
      {description && (
        Array.isArray(description) ? (
          <CardList>
            {description.map((item, index) => (
              <li key={index}>{item}</li>
            ))}
          </CardList>
        ) : (
          <CardDescription>{description}</CardDescription>
        )
      )}
      {children}
    </StyledCard>
  );
});

Card.displayName = 'Card';

const StyledCard = styled.div`
  background: ${({ theme }) => theme.palette.background.paper};
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  padding: ${({ theme }) => theme.spacing.lg};
  cursor: ${props => props.onClick ? 'pointer' : 'default'};
  transition: transform 0.2s ease, box-shadow 0.2s ease;

  &:hover {
    ${props => props.onClick && `
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    `}
  }
`;

const IconContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.palette.primary.main};
  
  img {
    max-width: 48px;
    height: auto;
  }
`;

const CardTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.palette.text.primary};
`;

const CardDescription = styled.p`
  color: ${({ theme }) => theme.palette.text.secondary};
`;

const CardList = styled.ul`
  list-style: none;
  padding: 0;
  margin: ${({ theme }) => theme.spacing.sm} 0;
  
  li {
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    color: ${({ theme }) => theme.palette.text.secondary};
  }
`;

export default Card;

========================================================================================
FILE: src/components/common/ConnectionStatus.tsx
========================================================================================
// File: /src/components/common/ConnectionStatus.tsx
// Description: Displays WebSocket connection status with retry functionality
// Author: GitHub Copilot
// Created: 2024

import React from 'react';
import styled, { keyframes, css } from 'styled-components';
import websocketService from '../../services/websocketService';

interface ConnectionStatusProps {
  className?: string;
  isConnected: boolean;
  onRetry?: () => void;
  showRetry?: boolean;
}

export const ConnectionStatus: React.FC<ConnectionStatusProps> = ({
  className,
  isConnected,
  onRetry,
  showRetry = true
}) => {
  const handleRetry = () => {
    websocketService.connect().catch(console.error);
    onRetry?.();
  };

  return (
    <Container className={className} $isConnected={isConnected}>
      <StatusDot $isConnected={isConnected} />
      <StatusText>
        {isConnected ? 'Connected' : 'Disconnected'}
      </StatusText>
      {!isConnected && showRetry && (
        <RetryButton onClick={handleRetry}>
          Retry Connection
        </RetryButton>
      )}
    </Container>
  );
};

const pulse = keyframes`
  0% {
    transform: scale(0.95);
    opacity: 0.5;
  }
  50% {
    transform: scale(1.05);
    opacity: 0.8;
  }
  100% {
    transform: scale(0.95);
    opacity: 0.5;
  }
`;

const Container = styled.div<{ $isConnected: boolean }>`
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem;
  border-radius: 0.25rem;
  background-color: ${props => props.$isConnected ? '#ecfdf5' : '#fff3cd'};
  color: ${props => props.$isConnected ? '#059669' : '#92400e'};
  transition: background-color 0.2s ease-in-out;
`;

const StatusDot = styled.div<{ $isConnected: boolean }>`
  width: 0.5rem;
  height: 0.5rem;
  border-radius: 50%;
  background-color: ${props => props.$isConnected ? '#059669' : '#92400e'};
  ${props => !props.$isConnected && css`
    animation: ${pulse} 2s ease-in-out infinite;
  `}
`;

const StatusText = styled.span`
  font-size: 0.875rem;
  font-weight: 500;
`;

const RetryButton = styled.button`
  margin-left: auto;
  padding: 0.25rem 0.5rem;
  border: none;
  border-radius: 0.25rem;
  background-color: #92400e;
  color: white;
  font-size: 0.75rem;
  cursor: pointer;
  transition: background-color 0.2s ease-in-out;

  &:hover {
    background-color: #78340f;
  }

  &:focus {
    outline: 2px solid #92400e;
    outline-offset: 2px;
  }
`;

export default ConnectionStatus;

========================================================================================
FILE: src/components/common/Input.tsx
========================================================================================
import React from 'react';
import styled from 'styled-components';

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  placeholder?: string;
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  error?: boolean;
}

const Input: React.FC<InputProps> = ({ placeholder, value, onChange, error, ...props }) => {
  return (
    <StyledInput
      placeholder={placeholder}
      value={value}
      onChange={onChange}
      error={error}
      {...props}
    />
  );
};

const StyledInput = styled.input<{ error?: boolean }>`
  padding: 0.75rem;
  border: 1px solid ${({ error }) => (error ? '#dc3545' : '#ddd')};
  border-radius: 4px;
  font-size: 1rem;

  &:focus {
    outline: none;
    border-color: ${({ error }) => (error ? '#dc3545' : '#4a90e2')};
    box-shadow: 0 0 0 2px ${({ error }) => (error ? 'rgba(220, 53, 69, 0.2)' : 'rgba(74, 144, 226, 0.2)')};
  }
`;

export default Input;

========================================================================================
FILE: src/components/common/StyledLink.tsx
========================================================================================
import styled from 'styled-components';
import { Link } from 'react-router-dom';

export interface StyledLinkProps {
  disabled?: boolean;
  variant?: 'primary' | 'secondary';
}

const StyledLink = styled(Link).attrs<StyledLinkProps>(({ disabled }) => ({
  role: 'button',
  'aria-disabled': disabled,
}))<StyledLinkProps>`
  display: inline-block;
  padding: var(--spacing-md) var(--spacing-lg);
  background: ${props => props.variant === 'secondary' ? 'var(--secondary-color)' : 'var(--primary-color)'};
  color: var(--white);
  border-radius: var(--border-radius);
  font-size: 1.1rem;
  text-decoration: none;
  text-align: center;
  cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};
  transition: background 0.2s, transform 0.2s;
  opacity: ${props => props.disabled ? 0.6 : 1};

  &:hover:not([aria-disabled="true"]) {
    background: ${props => props.variant === 'secondary' ? 'var(--primary-color)' : 'var(--secondary-color)'};
    transform: translateY(-2px);
  }

  &:focus-visible {
    outline: 2px dashed var(--secondary-color);
    outline-offset: 4px;
  }
`;

export default StyledLink;

========================================================================================
FILE: src/components/common/__tests__/ConnectionStatus.test.tsx
========================================================================================
// File: /src/components/common/__tests__/ConnectionStatus.test.tsx
// Description: Tests for ConnectionStatus component
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { ConnectionStatus } from '../ConnectionStatus';
import websocketService from '../../../services/websocketService';

// Mock websocketService
jest.mock('../../../services/websocketService', () => ({
  __esModule: true,
  default: {
    connect: jest.fn()
  }
}));

describe('ConnectionStatus', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('displays connected status when connected', () => {
    render(<ConnectionStatus isConnected={true} />);
    
    expect(screen.getByText('Connected')).toBeInTheDocument();
    expect(screen.queryByText('Retry Connection')).not.toBeInTheDocument();
  });

  it('displays disconnected status with retry button when disconnected', () => {
    render(<ConnectionStatus isConnected={false} />);
    
    expect(screen.getByText('Disconnected')).toBeInTheDocument();
    expect(screen.getByText('Retry Connection')).toBeInTheDocument();
  });

  it('hides retry button when showRetry is false', () => {
    render(<ConnectionStatus isConnected={false} showRetry={false} />);
    
    expect(screen.getByText('Disconnected')).toBeInTheDocument();
    expect(screen.queryByText('Retry Connection')).not.toBeInTheDocument();
  });

  it('calls connect and onRetry when retry button is clicked', () => {
    const mockOnRetry = jest.fn();
    render(<ConnectionStatus isConnected={false} onRetry={mockOnRetry} />);
    
    fireEvent.click(screen.getByText('Retry Connection'));
    
    expect(websocketService.connect).toHaveBeenCalled();
    expect(mockOnRetry).toHaveBeenCalled();
  });

  it('handles retry without onRetry callback', () => {
    render(<ConnectionStatus isConnected={false} />);
    
    fireEvent.click(screen.getByText('Retry Connection'));
    
    expect(websocketService.connect).toHaveBeenCalled();
    // Should not throw error without onRetry callback
  });

  it('applies custom className', () => {
    const { container } = render(
      <ConnectionStatus isConnected={true} className="custom-class" />
    );
    
    expect(container.firstChild).toHaveClass('custom-class');
  });
});

========================================================================================
FILE: src/components/common/types/index.ts
========================================================================================
// src/components/SomeComponent.tsx

import React from 'react';

// Reusable component prop types
export interface BaseComponentProps {
  className?: string;
  id?: string;
}

// Example component with proper types
export interface SomeComponentProps extends BaseComponentProps {
  title?: string;
}

// Use arrow function with explicit return for better type inference
export const SomeComponent: React.FC<SomeComponentProps> = ({ title = 'Hello, World!', className, id }): JSX.Element => {
  return React.createElement('div', { className, id },
    React.createElement('h1', null, title)
  );
};

// Example utility function with explicit return type
export const exampleFunction = (input: string): string => input.toUpperCase();

========================================================================================
FILE: src/config/dbConfig.ts
========================================================================================
// File: /src/config/dbConfig.ts
// Description: MongoDB configuration and connection setup
// Created: 2025-02-25

import mongoose from 'mongoose';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// MongoDB connection URI (use environment variable)
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/geaux-academy';

// Connection options
const options = {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  autoIndex: true,
};

// Connect to MongoDB
export const connectToDatabase = async (): Promise<void> => {
  try {
    await mongoose.connect(MONGODB_URI);
    console.log('Connected to MongoDB successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

// Close MongoDB connection
export const closeDatabaseConnection = async (): Promise<void> => {
  try {
    await mongoose.connection.close();
    console.log('MongoDB connection closed');
  } catch (error) {
    console.error('Error closing MongoDB connection:', error);
  }
};

// Export the mongoose instance for use in other files
export default mongoose;

========================================================================================
FILE: src/models/LearningPlan.ts
========================================================================================
// File: /src/models/LearningPlan.ts
// Description: MongoDB schema model for learning plans
// Created: 2025-02-25

import mongoose, { Schema, Document } from 'mongoose';

export interface ISubject {
  name: string;
  topics: {
    name: string;
    activities: {
      title: string;
      description: string;
      type: string;
      duration: string;
      resources?: string[];
    }[];
  }[];
}

export interface ILearningPlan extends Document {
  studentId: string;
  grade: string;
  learningStyle: string;
  subjects: ISubject[];
  startDate: Date;
  endDate?: Date;
  status: 'active' | 'completed' | 'pending';
  createdAt: Date;
  updatedAt: Date;
}

const LearningPlanSchema: Schema = new Schema(
  {
    studentId: { type: String, required: true, ref: 'Student' },
    grade: { type: String, required: true },
    learningStyle: { type: String, required: true },
    subjects: [{
      name: { type: String, required: true },
      topics: [{
        name: { type: String, required: true },
        activities: [{
          title: { type: String, required: true },
          description: { type: String, required: true },
          type: { type: String, required: true },
          duration: { type: String, required: true },
          resources: [{ type: String }]
        }]
      }]
    }],
    startDate: { type: Date, default: Date.now },
    endDate: { type: Date },
    status: { 
      type: String,
      enum: ['active', 'completed', 'pending'],
      default: 'pending'
    }
  },
  {
    timestamps: true,
  }
);

export default mongoose.models.LearningPlan || mongoose.model<ILearningPlan>('LearningPlan', LearningPlanSchema);

========================================================================================
FILE: src/models/User.ts
========================================================================================
// File: /src/models/User.ts
// Description: MongoDB schema model for users
// Created: 2025-02-25

import mongoose, { Schema, Document } from 'mongoose';

export interface IUser extends Document {
  uid: string;
  email: string;
  displayName?: string;
  photoURL?: string;
  createdAt: Date;
  updatedAt: Date;
  role: 'admin' | 'parent' | 'student' | 'teacher';
}

const UserSchema: Schema = new Schema(
  {
    uid: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    displayName: { type: String },
    photoURL: { type: String },
    role: { 
      type: String, 
      enum: ['admin', 'parent', 'student', 'teacher'],
      default: 'parent'
    },
  },
  {
    timestamps: true,
  }
);

export default mongoose.models.User || mongoose.model<IUser>('User', UserSchema);

========================================================================================
FILE: src/services/__tests__/websocketService.reconnect.test.ts
========================================================================================
// File: /src/services/__tests__/websocketService.reconnect.test.ts
import websocketService from '../websocketService';
import { WebSocketMock } from '../../test/mocks/WebSocketMock';

describe('WebSocketService - Reconnection', () => {
  let mockWebSocket: WebSocketMock;
  
  beforeEach(() => {
    jest.useFakeTimers();
    localStorage.getItem = jest.fn().mockResolvedValue('test-token');
    
    mockWebSocket = new WebSocketMock('ws://test.com');
    
    // Assign the mock constructor to global WebSocket
    (global as any).WebSocket = jest.fn().mockImplementation(() => mockWebSocket);
  });

  afterEach(() => {
    jest.useRealTimers();
    jest.restoreAllMocks();
  });

  it('should attempt reconnection with exponential backoff', async () => {
    const connectSpy = jest.spyOn(websocketService as any, 'connect');
    await websocketService.connect();

    // Simulate connection error and close
    mockWebSocket.mockError();
    mockWebSocket.mockClose();

    // First reconnect attempt (1s ± 30% jitter)
    jest.advanceTimersByTime(1000);
    expect(connectSpy).toHaveBeenCalledTimes(2);

    // Second reconnect attempt (2s ± 30% jitter)
    jest.advanceTimersByTime(2000);
    expect(connectSpy).toHaveBeenCalledTimes(3);

    // Third reconnect attempt (4s ± 30% jitter)
    jest.advanceTimersByTime(4000);
    expect(connectSpy).toHaveBeenCalledTimes(4);
  });

  it('should stop reconnecting after max attempts', async () => {
    const connectSpy = jest.spyOn(websocketService as any, 'connect');
    const errorHandler = jest.fn();
    websocketService.subscribe('error', errorHandler);
    
    await websocketService.connect();

    // Simulate multiple connection failures
    for (let i = 0; i < 6; i++) {
      mockWebSocket.mockError();
      mockWebSocket.mockClose();
      jest.advanceTimersByTime(30000);
    }

    expect(connectSpy).toHaveBeenCalledTimes(6); // Initial + 5 retries
    expect(errorHandler).toHaveBeenCalledWith(
      expect.any(Error)
    );
    expect(errorHandler.mock.calls[0][0].message).toMatch(/Failed to reconnect/);
  });

  it('should reset reconnection attempts on successful connection', async () => {
    await websocketService.connect();

    // Simulate two failed connections
    mockWebSocket.mockError();
    mockWebSocket.mockClose();
    jest.advanceTimersByTime(1000);
    
    mockWebSocket.mockError();
    mockWebSocket.mockClose();
    jest.advanceTimersByTime(2000);

    // Simulate successful connection
    mockWebSocket.mockSetReadyState(WebSocketMock.OPEN);
    mockWebSocket.mockOpen();

    // Verify attempts were reset by checking next reconnection
    mockWebSocket.mockError();
    mockWebSocket.mockClose();

    const reconnectSpy = jest.spyOn(websocketService as any, 'attemptReconnect');
    jest.advanceTimersByTime(1000);

    expect(reconnectSpy).toHaveBeenCalled();
    expect(websocketService as any).toHaveProperty('reconnectAttempts', 1);
  });

  it('should maintain message queue during reconnection', async () => {
    await websocketService.connect();
    
    // Queue a message while disconnected
    mockWebSocket.mockSetReadyState(WebSocketMock.CLOSED);
    websocketService.subscribeToTask('test-task');

    // Create new mock for reconnection
    const newMockWebSocket = new WebSocketMock('ws://test.com');
    const sendSpy = jest.spyOn(newMockWebSocket, 'send');
    
    // Update the mock WebSocket constructor
    (global as any).WebSocket = jest.fn().mockImplementation(() => newMockWebSocket);
    
    await websocketService.connect();
    newMockWebSocket.mockOpen();

    expect(sendSpy).toHaveBeenCalledWith(
      expect.stringContaining('test-task')
    );
  });
});

========================================================================================
FILE: src/services/__tests__/websocketService.test.ts
========================================================================================
// File: /src/services/__tests__/websocketService.test.ts
// Description: Unit tests for WebSocket service

import { WebSocketService } from '../websocketService';
import { TaskStatus, TaskResult } from '../../types/task';

// Mock WebSocket
class MockWebSocket {
  private listeners: Record<string, Function[]> = {
    open: [],
    message: [],
    close: [],
    error: []
  };
  public readyState = 0;

  constructor(public url: string) {
    setTimeout(() => {
      this.readyState = 1;
      this.listeners.open.forEach(listener => listener());
    }, 0);
  }

  addEventListener(event: string, listener: Function) {
    this.listeners[event].push(listener);
  }

  send(data: string) {}

  close() {
    this.readyState = 3;
    this.listeners.close.forEach(listener => listener());
  }

  // Helper to simulate incoming messages
  _receiveMessage(data: any) {
    this.listeners.message.forEach(listener => 
      listener({ data: JSON.stringify(data) })
    );
  }

  // Helper to simulate errors
  _triggerError() {
    this.listeners.error.forEach(listener => listener());
  }
}

// Mock localStorage
const mockLocalStorage = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  clear: jest.fn()
};

Object.defineProperty(window, 'localStorage', {
  value: mockLocalStorage
});

describe('WebSocketService', () => {
  let service: WebSocketService;
  const baseUrl = 'ws://test.com';

  beforeEach(() => {
    // Reset mocks
    mockLocalStorage.getItem.mockReset();
    mockLocalStorage.setItem.mockReset();
    mockLocalStorage.clear.mockReset();

    // Create new service instance
    service = new WebSocketService(baseUrl);

    // Mock WebSocket global
    (global as any).WebSocket = MockWebSocket;
  });

  it('should connect to WebSocket server with auth token', async () => {
    const mockToken = 'test-token';
    mockLocalStorage.getItem.mockResolvedValue(mockToken);

    let connected = false;
    service.subscribe('connect', () => {
      connected = true;
    });

    await service.connect();
    expect(connected).toBe(true);
  });

  it('should handle task updates correctly', async () => {
    mockLocalStorage.getItem.mockResolvedValue('test-token');
    await service.connect();

    const mockStatus: TaskStatus = {
      status: 'in_progress',
      task_id: 'test-123',
      last_updated: new Date().toISOString()
    };

    let receivedStatus: TaskStatus | null = null;
    service.subscribe('task_update', (status) => {
      receivedStatus = status;
    });

    // Simulate incoming task update
    (global as any).WebSocket.prototype._receiveMessage({
      type: 'task_update',
      status: mockStatus
    });

    expect(receivedStatus).toEqual(mockStatus);
  });

  it('should handle task results correctly', async () => {
    mockLocalStorage.getItem.mockResolvedValue('test-token');
    await service.connect();

    const mockResult: TaskResult = {
      content: { test: 'data' }
    };

    let receivedResult: TaskResult | null = null;
    service.subscribe('task_result', (result) => {
      receivedResult = result;
    });

    // Simulate incoming task result
    (global as any).WebSocket.prototype._receiveMessage({
      type: 'task_result',
      result: mockResult
    });

    expect(receivedResult).toEqual(mockResult);
  });

  it('should attempt reconnection on disconnect', async () => {
    mockLocalStorage.getItem.mockResolvedValue('test-token');
    await service.connect();

    let disconnectCount = 0;
    let connectCount = 0;

    service.subscribe('disconnect', () => {
      disconnectCount++;
    });

    service.subscribe('connect', () => {
      connectCount++;
    });

    // Simulate disconnect
    (global as any).WebSocket.prototype._triggerError();

    // Wait for reconnect attempt
    await new Promise(resolve => setTimeout(resolve, 2000));

    expect(disconnectCount).toBeGreaterThan(0);
    expect(connectCount).toBeGreaterThan(1);
  });

  it('should handle subscription acknowledgments', async () => {
    mockLocalStorage.getItem.mockResolvedValue('test-token');
    await service.connect();

    let receivedAck: { task_id: string } | null = null;
    service.subscribe('subscription_ack', (ack) => {
      receivedAck = ack;
    });

    const mockTaskId = 'test-123';
    service.subscribeToTask(mockTaskId);

    // Simulate subscription acknowledgment
    (global as any).WebSocket.prototype._receiveMessage({
      type: 'subscription_ack',
      task_id: mockTaskId
    });

    expect(receivedAck).toEqual({ task_id: mockTaskId });
  });

  it('should clean up resources on disconnect', async () => {
    mockLocalStorage.getItem.mockResolvedValue('test-token');
    await service.connect();

    let disconnected = false;
    service.subscribe('disconnect', () => {
      disconnected = true;
    });

    service.disconnect();
    expect(disconnected).toBe(true);
  });
});

========================================================================================
FILE: src/services/agentService.ts
========================================================================================
// frontend/src/services/agentService.ts
import { apiClient } from '../utils/apiClient';
import { TaskRequest, TaskStatus, TaskResult } from '../types/task';

export const agentService = {
  /**
   * Create a new agent task
   */
  createTask: async (taskRequest: TaskRequest): Promise<string> => {
    const response = await apiClient.post('/api/tasks', taskRequest);
    return response.data.task_id;
  },
  
  /**
   * Get the status of a task
   */
  getTaskStatus: async (taskId: string): Promise<TaskStatus> => {
    const response = await apiClient.get(`/api/tasks/${taskId}/status`);
    return response.data;
  },
  
  /**
   * Poll for task status until completion or error
   */
  pollTaskStatus: async (
    taskId: string, 
    onStatusUpdate: (status: TaskStatus) => void,
    intervalMs: number = 2000,
    maxAttempts: number = 30
  ): Promise<TaskResult | null> => {
    let attempts = 0;
    
    return new Promise((resolve, reject) => {
      const interval = setInterval(async () => {
        try {
          const status = await agentService.getTaskStatus(taskId);
          onStatusUpdate(status);
          
          if (status.status === 'completed') {
            clearInterval(interval);
            resolve(status.result);
          } else if (status.status === 'failed') {
            clearInterval(interval);
            reject(new Error(status.details || 'Task failed'));
          }
          
          attempts++;
          if (attempts >= maxAttempts) {
            clearInterval(interval);
            reject(new Error('Task polling timed out'));
          }
        } catch (error) {
          clearInterval(interval);
          reject(error);
        }
      }, intervalMs);
    });
  }
};

========================================================================================
FILE: src/services/auth-service.ts
========================================================================================
import { signInWithPopup, GoogleAuthProvider } from 'firebase/auth';
import { auth } from '../config/firebase';

export const signInWithGoogle = async () => {
  const provider = new GoogleAuthProvider();
  try {
    const result = await signInWithPopup(auth, provider);
    return result.user;
  } catch (error) {
    console.error('Google sign-in error:', error);
    throw new Error('Failed to sign in with Google');
  }
};

========================================================================================
FILE: src/services/dataService.ts
========================================================================================
import { supabase } from '@/supabaseClient';

export const fetchData = async () => {
  const { data, error } = await supabase.from('users').select('*');
  if (error) throw error;
  return data;
};

export const insertData = async (table: string, data: object) => {
  const { error } = await supabase.from(table).insert(data);
  if (error) throw error;
};

export const updateData = async (table: string, id: number, data: object) => {
  const { error } = await supabase.from(table).update(data).eq('id', id);
  if (error) throw error;
};

export const deleteData = async (table: string, id: number) => {
  const { error } = await supabase.from(table).delete().eq('id', id);
  if (error) throw error;
};

========================================================================================
FILE: src/services/mongoService.ts
========================================================================================
import axios from 'axios';
import { firebaseService } from './firebaseService';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL;

// Create axios instance
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Add auth token to requests
apiClient.interceptors.request.use(async (config) => {
  const token = await firebaseService.getIdToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export const mongoService = {
  // User profile operations
  getUserProfile: async (userId: string) => {
    const response = await apiClient.get(`/users/${userId}`);
    return response.data;
  },
  
  updateUserProfile: async (userId: string, profileData: any) => {
    const response = await apiClient.put(`/users/${userId}`, profileData);
    return response.data;
  },
  
  // Learning style operations
  saveLearningStyle: async (userId: string, learningStyle: string, assessmentResults: any) => {
    const response = await apiClient.post(`/users/${userId}/learning-style`, {
      style: learningStyle,
      results: assessmentResults
    });
    return response.data;
  },
  
  getLearningStyle: async (userId: string) => {
    const response = await apiClient.get(`/users/${userId}/learning-style`);
    return response.data;
  },
  
  // Curriculum operations
  saveCurriculum: async (userId: string, curriculum: any) => {
    const response = await apiClient.post(`/users/${userId}/curriculum`, curriculum);
    return response.data;
  },
  
  getCurriculumList: async (userId: string) => {
    const response = await apiClient.get(`/users/${userId}/curriculum`);
    return response.data;
  },
  
  getCurriculumById: async (userId: string, curriculumId: string) => {
    const response = await apiClient.get(`/users/${userId}/curriculum/${curriculumId}`);
    return response.data;
  }
};

========================================================================================
FILE: src/services/mongodbService.ts
========================================================================================
// File: /src/services/mongodbService.ts
// Description: Service for MongoDB operations replacing Firestore functionality
// Created: 2025-02-25

import { connectToDatabase } from '../config/dbConfig';

// Connect to MongoDB when the service is imported
connectToDatabase()
  .then(() => console.log('MongoDB service initialized'))
  .catch(err => console.error('Failed to initialize MongoDB service:', err));

// Generic get document function
export async function getData<T>(model: any, id: string): Promise<T | null> {
  try {
    const document = await model.findOne({ uid: id }).lean();
    return document as T | null;
  } catch (error) {
    console.error(`Error getting document with ID ${id}:`, error);
    throw error;
  }
}

// Generic get documents function
export async function getDocuments<T>(model: any, filter = {}): Promise<T[]> {
  try {
    const documents = await model.find(filter).lean();
    return documents as T[];
  } catch (error) {
    console.error(`Error getting documents:`, error);
    throw error;
  }
}

// Generic set document function
export async function setData<T>(model: any, id: string, data: Partial<T>): Promise<T> {
  try {
    const update = { ...data };
    const options = { new: true, upsert: true, setDefaultsOnInsert: true };
    
    const document = await model.findOneAndUpdate(
      { uid: id }, 
      update, 
      options
    ).lean();
    
    return document as T;
  } catch (error) {
    console.error(`Error setting document with ID ${id}:`, error);
    throw error;
  }
}

// Generic create document function
export async function createData<T>(model: any, data: T): Promise<T> {
  try {
    const newDocument = new model(data);
    await newDocument.save();
    return newDocument.toObject() as T;
  } catch (error) {
    console.error(`Error creating document:`, error);
    throw error;
  }
}

// Generic update document function
export async function updateData<T>(model: any, id: string, data: Partial<T>): Promise<T | null> {
  try {
    const updatedDocument = await model.findOneAndUpdate(
      { uid: id }, 
      { $set: { ...data, updatedAt: new Date() } }, 
      { new: true }
    ).lean();
    
    return updatedDocument as T | null;
  } catch (error) {
    console.error(`Error updating document with ID ${id}:`, error);
    throw error;
  }
}

// Generic delete document function
export async function deleteData(model: any, id: string): Promise<boolean> {
  try {
    const result = await model.deleteOne({ uid: id });
    return result.deletedCount > 0;
  } catch (error) {
    console.error(`Error deleting document with ID ${id}:`, error);
    throw error;
  }
}

========================================================================================
FILE: src/services/userService.ts
========================================================================================
// File: /src/services/userService.ts
// Description: MongoDB service for user operations
// Created: 2025-02-25

import User, { IUser } from '../models/User';
import { getData, getDocuments, setData, updateData, deleteData } from './mongodbService';

// Get user by Firebase Auth UID
export const getUserById = async (uid: string): Promise<IUser | null> => {
  return await getData<IUser>(User, uid);
};

// Get users by role
export const getUsersByRole = async (role: string): Promise<IUser[]> => {
  return await getDocuments<IUser>(User, { role });
};

// Create or update user
export const createOrUpdateUser = async (userData: Partial<IUser>): Promise<IUser> => {
  if (!userData.uid) {
    throw new Error('User ID is required');
  }
  
  return await setData<IUser>(User, userData.uid, userData);
};

// Update user profile
export const updateUserProfile = async (uid: string, userData: Partial<IUser>): Promise<IUser | null> => {
  return await updateData<IUser>(User, uid, userData);
};

// Delete user
export const deleteUser = async (uid: string): Promise<boolean> => {
  return await deleteData(User, uid);
};

// Create user profile from Firebase Auth user
export const createUserFromAuth = async (firebaseUser: any): Promise<IUser> => {
  const userData: Partial<IUser> = {
    uid: firebaseUser.uid,
    email: firebaseUser.email,
    displayName: firebaseUser.displayName || '',
    photoURL: firebaseUser.photoURL || '',
    role: 'parent', // Default role
  };
  
  return await createOrUpdateUser(userData);
};

========================================================================================
FILE: src/services/websocketService.ts
========================================================================================
// File: /src/services/websocketService.ts
// Description: WebSocket service for handling real-time task updates
import { TaskStatus, TaskResult } from '../types/task';

export interface WebSocketMessage {
  type: string;
  task_id?: string;
  status?: TaskStatus;
  result?: TaskResult;
  error?: string;
}

interface WebSocketEventMap {
  connect: void;
  disconnect: void;
  error: Error;
  task_update: TaskStatus;
  task_result: TaskResult;
  subscription_ack: { task_id: string };
}

type WebSocketEventListener<K extends keyof WebSocketEventMap> = 
  (data: WebSocketEventMap[K]) => void;

type EventListeners = {
  [K in keyof WebSocketEventMap]: Set<WebSocketEventListener<K>>;
};

class WebSocketService {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectTimeout: number | null = null;
  // Change the listeners type to use a more flexible Record type
  private listeners: Record<keyof WebSocketEventMap, Set<any>> = {
    connect: new Set(),
    disconnect: new Set(),
    error: new Set(),
    task_update: new Set(),
    task_result: new Set(),
    subscription_ack: new Set()
  };
  private pendingMessages: string[] = [];
  private isConnecting = false;

  constructor(private readonly baseUrl: string) {
    // Force ws:// for local development
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      this.baseUrl = 'ws://localhost:5173';
    }
  }

  private async getAuthToken(): Promise<string | null> {
    try {
      // This should be implemented based on your authentication method
      return await localStorage.getItem('auth_token');
    } catch (error) {
      console.error('Error getting auth token:', error);
      return null;
    }
  }

  async connect(): Promise<void> {
    if (this.ws?.readyState === WebSocket.OPEN || this.isConnecting) {
      return;
    }

    this.isConnecting = true;

    try {
      const token = await this.getAuthToken();
      if (!token) {
        throw new Error('No authentication token available');
      }

      this.ws = new WebSocket(`${this.baseUrl}/ws/tasks/${token}`);
      
      this.ws.onopen = () => {
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.emit('connect', undefined);
        
        // Send any pending messages
        while (this.pendingMessages.length > 0) {
          const message = this.pendingMessages.shift();
          if (message) this.send(message);
        }
      };

      this.ws.onmessage = (event) => {
        try {
          const message: WebSocketMessage = JSON.parse(event.data);
          
          switch (message.type) {
            case 'task_update':
              if (message.status) {
                this.emit('task_update', message.status);
              }
              break;
            
            case 'task_result':
              if (message.result) {
                this.emit('task_result', message.result);
              }
              break;
            
            case 'subscription_ack':
              if (message.task_id) {
                this.emit('subscription_ack', { task_id: message.task_id });
              }
              break;
            
            case 'error':
              if (message.error) {
                this.emit('error', new Error(message.error));
              }
              break;
          }
        } catch (error) {
          console.error('Error parsing WebSocket message:', error);
        }
      };

      this.ws.onclose = () => {
        this.isConnecting = false;
        this.emit('disconnect', undefined);
        this.attemptReconnect();
      };

      this.ws.onerror = (error) => {
        this.isConnecting = false;
        this.emit('error', new Error('WebSocket error occurred'));
      };
    } catch (error) {
      this.isConnecting = false;
      throw error;
    }
  }

  private getBackoffDelay(): number {
    // Calculate exponential backoff with random jitter
    const minDelay = 1000; // 1 second minimum
    const maxDelay = 30000; // 30 seconds maximum
    const baseDelay = Math.min(
      minDelay * Math.pow(2, this.reconnectAttempts),
      maxDelay
    );
    
    // Add random jitter (±30%)
    const jitter = baseDelay * 0.3 * (Math.random() * 2 - 1);
    return Math.max(minDelay, Math.min(baseDelay + jitter, maxDelay));
  }

  private attemptReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      this.emit('error', new Error('Failed to reconnect after maximum attempts'));
      return;
    }

    if (this.reconnectTimeout !== null) {
      clearTimeout(this.reconnectTimeout);
    }

    const delay = this.getBackoffDelay();
    
    this.reconnectTimeout = window.setTimeout(() => {
      this.reconnectAttempts++;
      this.connect().catch(error => {
        console.error('Reconnection failed:', error);
      });
    }, delay);
  }

  subscribe<K extends keyof WebSocketEventMap>(
    event: K,
    listener: WebSocketEventListener<K>
  ): () => void {
    this.listeners[event].add(listener);
    
    return () => {
      this.listeners[event].delete(listener);
    };
  }

  private emit<K extends keyof WebSocketEventMap>(
    event: K,
    data: WebSocketEventMap[K]
  ): void {
    this.listeners[event].forEach((listener: WebSocketEventListener<K>) => {
      try {
        listener(data);
      } catch (error) {
        console.error(`Error in ${event} listener:`, error);
      }
    });
  }

  subscribeToTask(taskId: string): void {
    const message = JSON.stringify({
      type: 'subscribe_task',
      task_id: taskId
    });

    if (this.ws?.readyState === WebSocket.OPEN) {
      this.send(message);
    } else {
      this.pendingMessages.push(message);
      this.connect().catch(error => {
        console.error('Error connecting to WebSocket:', error);
      });
    }
  }

  private send(message: string): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(message);
    } else {
      this.pendingMessages.push(message);
    }
  }

  disconnect(): void {
    if (this.reconnectTimeout !== null) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  hasActiveSubscriptions(): boolean {
    // Check if there are any active listeners for task-related events
    return (
      this.listeners.task_update.size > 0 ||
      this.listeners.task_result.size > 0 ||
      this.listeners.subscription_ack.size > 0
    );
  }
}

export const websocketService = new WebSocketService(
  process.env.REACT_APP_WS_BASE_URL || 'ws://localhost:5173'
);

export default websocketService;

========================================================================================
FILE: src/types/css.d.ts
========================================================================================
declare module '*.module.css' {
  const classes: { [key: string]: string };
  export default classes;
}

declare module '*.css' {
  const css: { [key: string]: string };
  export default css;
}

========================================================================================
FILE: src/types/dashboard.ts
========================================================================================

export interface StudentProgress {
  completionRate: number;
  timeSpent: number;
  accuracy: number;
  subjectProgress: {
    [subject: string]: {
      completed: number;
      total: number;
    };
  };
}

export interface LearningStyle {
  visual: number;
  auditory: number;
  reading: number;
  kinesthetic: number;
  recommendations: string[];
}

export interface DashboardState {
  activeTab: 'overview' | 'progress' | 'learning-styles' | 'curriculum';
  studentData: {
    progress: StudentProgress;
    learningStyle: LearningStyle;
  } | null;
}

========================================================================================
FILE: src/types/firebase.d.ts
========================================================================================
// File: /src/types/firebase.d.ts
// Description: Type declarations for Firebase modules
// Author: GitHub Copilot
// Created: 2024-02-12

declare module 'firebase/app' {
  export * from '@firebase/app';
}

declare module 'firebase/auth' {
  export * from '@firebase/auth';
}

declare module 'firebase/firestore' {
  export * from '@firebase/firestore';
}

declare module 'firebase/analytics' {
  export * from '@firebase/analytics';
}

declare module 'firebase/messaging' {
  export * from '@firebase/messaging';
}

========================================================================================
FILE: src/types/service-worker.d.ts
========================================================================================


========================================================================================
FILE: src/types/styled.d.ts
========================================================================================
import 'styled-components';
import { Theme } from '@mui/material/styles';

declare module 'styled-components' {
  export interface DefaultTheme extends Theme {
    breakpoints: Theme['breakpoints'] & {
      mobile: string;
      tablet: string;
      desktop: string;
      large: string;
    };
    spacing: Theme['spacing'] & {
      xs: string;
      sm: string;
      md: string;
      lg: string;
      xl: string;
    };
    colors: {
      border: string;
      text: string;
      muted: string;
      accent: string;
      background: {
        hover: string;
        subtle: string;
      };
      error: {
        main: string;
        light: string;
      };
    };
    borderRadius: {
      xs: string;
      sm: string;
      md: string;
      lg: string;
      pill: string;
    };
    shadows: {
      sm: string;
      md: string;
      glow: string;
    };
    gradients: {
      hero: string;
      card: string;
    };
  }
}

========================================================================================
FILE: src/types/task.ts
========================================================================================
// File: /src/types/task.ts
// Description: Type definitions for task-related data structures
// Author: GitHub Copilot
// Created: 2024

export interface TaskStatus {
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  task_id: string;
  last_updated?: string;
  details?: string;
}

export interface TaskResult {
  content: any;
  metadata?: {
    agent_id?: string;
    agent_name?: string;
    agent_role?: string;
    [key: string]: any;
  };
}

export interface TaskRequest {
  task_type: string;
  subject: string;
  grade_level: string;
  learning_style: string;
  custom_params?: Record<string, any>;
}

========================================================================================
FILE: src/types/types.ts
========================================================================================
// File: /types/types.ts
// Description: Core type definitions for user profiles, assessments, and course progress
// Author: Geaux Academy Team
// Created: 2024
export interface ParentProfile {
  uid: string;
  email: string;
  displayName: string;
  students: StudentProfile[];
}

export interface StudentProfile {
  id: string;
  parentId: string;
  firstName: string;
  lastName: string;
  age: number;
  grade: string;
  learningStyle?: LearningStyle;
  assessmentResults?: AssessmentResult[];
  progress?: CourseProgress[];
}

export interface LearningStyle {
  type: 'visual' | 'auditory' | 'kinesthetic' | 'reading/writing';
  strengths: string[];
  recommendations: string[];
}

export interface AssessmentResult {
  date: string;
  score: number;
  subject: string;
  details: Record<string, unknown>;
}

export interface CourseProgress {
  courseId: string;
  completed: number;
  total: number;
  lastAccessed: string;
}

========================================================================================
FILE: src/types/userTypes.ts
========================================================================================

export interface BaseProfile {
  uid: string;
  email: string;
  displayName: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ParentProfile extends BaseProfile {
  role: 'parent';
  phone?: string;
  students: StudentProfile[];
}

export interface StudentProfile extends BaseProfile {
  role: 'student';
  parentId: string;
  grade: string;
  dateOfBirth: Date;
}

---- END OF EXPORT ----

