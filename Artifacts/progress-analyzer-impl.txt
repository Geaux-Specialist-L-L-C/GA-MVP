from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class PerformanceMetric:
    """Structure for tracking performance metrics"""
    metric_name: str
    value: float
    timestamp: datetime
    details: Optional[Dict] = None

@dataclass
class LearningProgress:
    """Structure for tracking learning progress"""
    subject: str
    topic: str
    start_date: datetime
    current_level: str
    completed_objectives: List[str]
    metrics: List[PerformanceMetric]
    next_steps: List[str]

class ProgressAnalyzer:
    """Enhanced implementation of the Progress Analyzer agent"""
    
    def __init__(self):
        self.performance_thresholds = {
            "mastery": 0.9,
            "proficient": 0.8,
            "developing": 0.6,
            "needs_support": 0.0
        }
        
        self.metric_weights = {
            "quiz_scores": 0.3,
            "assignment_completion": 0.2,
            "participation": 0.1,
            "project_scores": 0.4
        }

    def analyze_performance(self, student_data: Dict) -> Dict:
        """
        Analyze student performance data comprehensively
        
        Args:
            student_data: Dictionary containing student performance data
            
        Returns:
            Dictionary containing analysis results and recommendations
        """
        try:
            logger.info("Starting performance analysis")
            
            # Extract relevant data
            subject_data = student_data.get("progress", {})
            current_unit = subject_data.get("current_unit", "")
            scores = subject_data.get("scores", [])
            
            # Calculate key metrics
            metrics = self._calculate_performance_metrics(scores)
            
            # Analyze trends
            trend_analysis = self._analyze_performance_trends(scores)
            
            # Identify strengths and weaknesses
            strengths, weaknesses = self._identify_strengths_weaknesses(metrics)
            
            # Generate mastery level
            mastery_level = self._determine_mastery_level(metrics["average_score"])
            
            # Create learning pathway recommendations
            recommendations = self._generate_recommendations(
                mastery_level,
                strengths,
                weaknesses
            )
            
            return {
                "current_unit": current_unit,
                "performance_metrics": metrics,
                "trend_analysis": trend_analysis,
                "mastery_level": mastery_level,
                "strengths": strengths,
                "weaknesses": weaknesses,
                "recommendations": recommendations
            }
            
        except Exception as e:
            logger.error(f"Error identifying strengths/weaknesses: {str(e)}")
            raise

    def _determine_mastery_level(self, average_score: float) -> str:
        """Determine the student's mastery level"""
        try:
            for level, threshold in self.performance_thresholds.items():
                if average_score >= threshold:
                    return level
            return "needs_support"
            
        except Exception as e:
            logger.error(f"Error determining mastery level: {str(e)}")
            raise

    def _generate_recommendations(
        self,
        mastery_level: str,
        strengths: List[str],
        weaknesses: List[str]
    ) -> List[Dict]:
        """Generate personalized learning recommendations"""
        try:
            recommendations = []
            
            # Base recommendations on mastery level
            if mastery_level == "mastery":
                recommendations.append({
                    "type": "advancement",
                    "description": "Ready for advanced content",
                    "actions": [
                        "Introduce challenge problems",
                        "Assign extension projects",
                        "Consider peer tutoring opportunities"
                    ]
                })
                
            elif mastery_level == "proficient":
                recommendations.append({
                    "type": "reinforcement",
                    "description": "Strengthen current understanding",
                    "actions": [
                        "Practice complex problems",
                        "Connect concepts to real-world applications",
                        "Review challenging topics"
                    ]
                })
                
            elif mastery_level == "developing":
                recommendations.append({
                    "type": "support",
                    "description": "Build foundational understanding",
                    "actions": [
                        "Review core concepts",
                        "Provide additional practice",
                        "Use varied learning materials"
                    ]
                })
                
            else:  # needs_support
                recommendations.append({
                    "type": "intervention",
                    "description": "Address learning gaps",
                    "actions": [
                        "Identify specific areas of difficulty",
                        "Provide targeted instruction",
                        "Use scaffolded learning activities"
                    ]
                })
            
            # Add recommendations based on weaknesses
            for weakness in weaknesses:
                if "inconsistent" in weakness.lower():
                    recommendations.append({
                        "type": "consistency",
                        "description": "Improve performance consistency",
                        "actions": [
                            "Establish regular study routine",
                            "Use progress tracking tools",
                            "Practice time management"
                        ]
                    })
                elif "trending downward" in weakness.lower():
                    recommendations.append({
                        "type": "trend_correction",
                        "description": "Address declining performance",
                        "actions": [
                            "Review recent topics thoroughly",
                            "Identify potential obstacles",
                            "Adjust learning strategies"
                        ]
                    })
            
            return recommendations
            
        except Exception as e:
            logger.error(f"Error generating recommendations: {str(e)}")
            raise

    def generate_progress_report(self, analysis_results: Dict) -> Dict:
        """Generate a comprehensive progress report"""
        try:
            report = {
                "timestamp": datetime.now().isoformat(),
                "summary": {
                    "current_unit": analysis_results["current_unit"],
                    "mastery_level": analysis_results["mastery_level"],
                    "overall_status": self._generate_status_summary(analysis_results)
                },
                "detailed_metrics": analysis_results["performance_metrics"],
                "trends": analysis_results["trend_analysis"],
                "strengths_weaknesses": {
                    "strengths": analysis_results["strengths"],
                    "weaknesses": analysis_results["weaknesses"]
                },
                "recommendations": analysis_results["recommendations"],
                "next_steps": self._generate_next_steps(analysis_results)
            }
            
            return report
            
        except Exception as e:
            logger.error(f"Error generating progress report: {str(e)}")
            raise

    def _generate_status_summary(self, analysis_results: Dict) -> str:
        """Generate a brief status summary"""
        try:
            mastery_level = analysis_results["mastery_level"]
            trend = analysis_results["trend_analysis"]["recent_performance"]
            
            if mastery_level in ["mastery", "proficient"] and trend == "improving":
                return "Excellent progress - ready for advancement"
            elif mastery_level == "mastery":
                return "Strong performance - maintain current level"
            elif mastery_level == "proficient" and trend != "declining":
                return "Good progress - continue current approach"
            elif mastery_level == "developing" and trend == "improving":
                return "Showing improvement - continue support"
            elif mastery_level == "needs_support":
                return "Requires additional support and intervention"
            else:
                return "Steady progress - monitor and adjust as needed"
                
        except Exception as e:
            logger.error(f"Error generating status summary: {str(e)}")
            raise

    def _generate_next_steps(self, analysis_results: Dict) -> List[str]:
        """Generate specific next steps based on analysis"""
        try:
            next_steps = []
            
            # Add mastery-level based steps
            if analysis_results["mastery_level"] == "mastery":
                next_steps.extend([
                    "Introduce advanced topics",
                    "Assign challenging projects",
                    "Explore enrichment opportunities"
                ])
            elif analysis_results["mastery_level"] == "proficient":
                next_steps.extend([
                    "Continue current curriculum pace",
                    "Add some challenge problems",
                    "Reinforce key concepts"
                ])
            elif analysis_results["mastery_level"] == "developing":
                next_steps.extend([
                    "Review fundamental concepts",
                    "Increase practice opportunities",
                    "Monitor progress closely"
                ])
            else:  # needs_support
                next_steps.extend([
                    "Schedule additional support sessions",
                    "Break down complex topics",
                    "Use alternative learning materials"
                ])
            
            # Add trend-based steps
            if analysis_results["trend_analysis"]["volatility"] == "high":
                next_steps.append("Implement consistent study routine")
            
            if analysis_results["trend_analysis"]["recent_performance"] == "declining":
                next_steps.append("Review recent topics thoroughly")
            
            return next_steps
            
        except Exception as e:
            logger.error(f"Error generating next steps: {str(e)}")
            raise analyzing performance: {str(e)}")
            raise

    def _calculate_performance_metrics(self, scores: List[float]) -> Dict:
        """Calculate key performance metrics"""
        try:
            if not scores:
                return {
                    "average_score": 0,
                    "trend": "insufficient_data",
                    "consistency": 0
                }
            
            metrics = {
                "average_score": np.mean(scores),
                "median_score": np.median(scores),
                "highest_score": max(scores),
                "lowest_score": min(scores),
                "score_range": max(scores) - min(scores),
                "standard_deviation": np.std(scores) if len(scores) > 1 else 0,
                "total_assessments": len(scores)
            }
            
            # Calculate improvement trend
            if len(scores) > 1:
                X = np.array(range(len(scores))).reshape(-1, 1)
                y = np.array(scores)
                reg = LinearRegression().fit(X, y)
                metrics["trend_slope"] = reg.coef_[0]
                metrics["trend"] = "improving" if reg.coef_[0] > 0 else "declining"
            else:
                metrics["trend"] = "insufficient_data"
                metrics["trend_slope"] = 0
                
            return metrics
            
        except Exception as e:
            logger.error(f"Error calculating metrics: {str(e)}")
            raise

    def _analyze_performance_trends(self, scores: List[float]) -> Dict:
        """Analyze trends in performance data"""
        try:
            if len(scores) < 3:
                return {"trend_type": "insufficient_data"}
            
            # Convert to pandas series for easier analysis
            score_series = pd.Series(scores)
            
            trend_analysis = {
                "overall_trend": "stable",
                "volatility": "low",
                "recent_performance": "consistent"
            }
            
            # Calculate rolling average
            rolling_avg = score_series.rolling(window=3).mean()
            
            # Analyze recent trend (last 3 scores)
            recent_scores = scores[-3:]
            recent_trend = np.polyfit(range(len(recent_scores)), recent_scores, 1)[0]
            
            if recent_trend > 0.05:
                trend_analysis["recent_performance"] = "improving"
            elif recent_trend < -0.05:
                trend_analysis["recent_performance"] = "declining"
            
            # Calculate volatility
            volatility = score_series.std()
            if volatility > 15:
                trend_analysis["volatility"] = "high"
            elif volatility > 8:
                trend_analysis["volatility"] = "medium"
            
            return trend_analysis
            
        except Exception as e:
            logger.error(f"Error analyzing trends: {str(e)}")
            raise

    def _identify_strengths_weaknesses(self, metrics: Dict) -> tuple:
        """Identify areas of strength and weakness"""
        try:
            strengths = []
            weaknesses = []
            
            # Analyze average score
            if metrics["average_score"] >= self.performance_thresholds["mastery"]:
                strengths.append("Consistently high performance")
            elif metrics["average_score"] < self.performance_thresholds["developing"]:
                weaknesses.append("Overall performance needs improvement")
            
            # Analyze consistency
            if metrics["standard_deviation"] < 5:
                strengths.append("Consistent performance")
            elif metrics["standard_deviation"] > 15:
                weaknesses.append("Inconsistent performance")
            
            # Analyze trend
            if metrics["trend"] == "improving":
                strengths.append("Showing improvement over time")
            elif metrics["trend"] == "declining":
                weaknesses.append("Performance trending downward")
            
            return strengths, weaknesses
            
        except Exception as e:
            logger.error(f"Error