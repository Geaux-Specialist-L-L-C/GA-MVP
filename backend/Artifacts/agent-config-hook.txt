// File: /src/hooks/useAgentConfigStatus.ts
import { useState, useEffect, useCallback } from 'react';
import { collection, query, where, onSnapshot, Timestamp } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import { useDeployment } from '@/contexts/DeploymentContext';
import { AgentConfig } from '@/hooks/useDeploymentConfig';

interface AgentHeartbeat {
  agentId: string;
  timestamp: Date;
  configVersion: string;
  status: 'healthy' | 'degraded' | 'error';
  metrics: {
    memory: number;
    cpu: number;
    activeRequests: number;
    queueLength: number;
    errorRate: number;
  };
}

interface AgentConfigStatus {
  agentId: string;
  currentConfig: Partial<AgentConfig>;
  pendingConfig: Partial<AgentConfig> | null;
  lastHeartbeat: AgentHeartbeat | null;
  updateStatus: 'idle' | 'updating' | 'error';
  error?: string;
  lastUpdateAttempt?: Date;
}

export const useAgentConfigStatus = () => {
  const { config } = useDeployment();
  const [agentStatuses, setAgentStatuses] = useState<Record<string, AgentConfigStatus>>({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Subscribe to agent heartbeats
  useEffect(() => {
    if (!config) return;

    const heartbeatsRef = collection(db, 'agentHeartbeats');
    const heartbeatsQuery = query(
      heartbeatsRef,
      where('configVersion', '==', config.version)
    );

    const unsubscribe = onSnapshot(
      heartbeatsQuery,
      {
        next: (snapshot) => {
          const updatedHeartbeats = new Map<string, AgentHeartbeat>();
          
          snapshot.docs.forEach(doc => {
            const data = doc.data();
            updatedHeartbeats.set(data.agentId, {
              agentId: data.agentId,
              timestamp: data.timestamp.toDate(),
              configVersion: data.configVersion,
              status: data.status,
              metrics: data.metrics
            });
          });

          setAgentStatuses(current => {
            const updated = { ...current };
            
            // Update heartbeats for existing agents
            Object.keys(updated).forEach(agentId => {
              const heartbeat = updatedHeartbeats.get(agentId);
              if (heartbeat) {
                updated[agentId] = {
                  ...updated[agentId],
                  lastHeartbeat: heartbeat
                };
              }
            });

            return updated;
          });
        },
        error: (err) => {
          setError(`Error monitoring agent heartbeats: ${err.message}`);
        }
      }
    );

    return () => unsubscribe();
  }, [config]);

  // Subscribe to agent config status
  useEffect(() => {
    if (!config) return;

    const configStatusRef = collection(db, 'agentConfigStatus');
    const statusQuery = query(
      configStatusRef,
      where('environment', '==', config.environment)
    );

    const unsubscribe = onSnapshot(
      statusQuery,
      {
        next: (snapshot) => {
          const newStatuses: Record<string, AgentConfigStatus> = {};
          
          snapshot.docs.forEach(doc => {
            const data = doc.data();
            newStatuses[data.agentId] = {
              agentId: data.agentId,
              currentConfig: data.currentConfig,
              pendingConfig: data.pendingConfig || null,
              lastHeartbeat: null, // Will be updated by heartbeat subscription
              updateStatus: data.updateStatus,
              error: data.error,
              lastUpdateAttempt: data.lastUpdateAttempt?.toDate()
            };
          });

          setAgentStatuses(current => ({
            ...newStatuses,
            // Preserve heartbeat data from current state
            ...Object.keys(newStatuses).reduce((acc, agentId) => ({
              ...acc,
              [agentId]: {
                ...newStatuses[agentId],
                lastHeartbeat: current[agentId]?.lastHeartbeat || null
              }
            }), {})
          }));
          
          setLoading(false);
        },
        error: (err) => {
          setError(`Error monitoring agent config status: ${err.message}`);
          setLoading(false);
        }
      }
    );

    