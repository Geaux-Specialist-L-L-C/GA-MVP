# Edge Case Handling Prompts

## Curriculum Management Edge Cases

### Content Scraping Resilience
```prompt
Implement robust error handling for the CurriculumResearcher that handles:
- Rate-limited websites
- Dynamic JavaScript content
- Malformed HTML
- Network timeouts
- Blocked IP addresses
- Changed website structures

Example implementation:
class ResilientScraper:
    def __init__(self):
        self.proxy_manager = ProxyManager()
        self.retry_strategy = ExponentialBackoff()
        
    async def scrape_with_fallback(self, url: str) -> Dict:
        """Scrape with multiple fallback mechanisms"""
        try:
            return await self._primary_scrape(url)
        except RateLimitError:
            return await self._rotate_proxy_and_retry(url)
        except DynamicContentError:
            return await self._use_browser_render(url)
        except NetworkTimeoutError:
            return await self._retry_with_backoff(url)
```

### Incomplete Curriculum Data
```prompt
Create handlers for incomplete or inconsistent curriculum data:
- Missing prerequisites
- Broken topic sequences
- Incomplete standards mapping
- Contradictory requirements
- Grade level mismatches
- Resource gaps

Example structure:
class CurriculumValidator:
    def validate_and_repair(
        self,
        curriculum_data: Dict,
        grade_level: int
    ) -> Dict:
        """Validate and attempt to repair curriculum data"""
        try:
            self._validate_prerequisites()
            self._ensure_sequence_continuity()
            self._verify_standards_mapping()
            self._check_grade_alignment()
            self._identify_resource_gaps()
            return self._repair_issues()
        except ValidationError as e:
            return self._generate_partial_curriculum(e.valid_components)
```

## Progress Tracking Edge Cases

### Inconsistent Performance Data
```prompt
Handle edge cases in performance tracking:
- Missing assessment data
- Irregular assessment intervals
- Inconsistent scoring scales
- Incomplete assignments
- Interrupted learning periods
- Data from multiple sources

Implementation example:
class PerformanceNormalizer:
    def normalize_data(
        self,
        performance_data: List[Dict],
        expected_metrics: List[str]
    ) -> Dict:
        """Normalize inconsistent performance data"""
        try:
            # Handle missing data
            filled_data = self._fill_missing_data(performance_data)
            
            # Normalize scoring scales
            normalized_scores = self._normalize_scores(filled_data)
            
            # Adjust for irregular intervals
            adjusted_data = self._adjust_intervals(normalized_scores)
            
            # Combine multiple sources
            combined_data = self._combine_sources(adjusted_data)
            
            return combined_data
            
        except DataInconsistencyError:
            return self._generate_partial_analysis()
```

### Learning Pattern Anomalies
```prompt
Implement detection and handling of learning pattern anomalies:
- Sudden performance changes
- Inconsistent engagement
- Multiple learning styles
- Changing pace
- Mixed mastery levels
- Irregular attendance

Example structure:
class AnomalyDetector:
    def analyze_patterns(
        self,
        student_data: Dict,
        timeframe: str
    ) -> Dict:
        """Detect and analyze learning pattern anomalies"""
        anomalies = {
            'performance_shifts': self._detect_performance_shifts(),
            'engagement_patterns': self._analyze_engagement(),
            'learning_style_changes': self._track_style_changes(),
            'pace_variations': self._measure_pace_changes(),
            'mastery_inconsistencies': self._find_mastery_gaps()
        }
        
        return self._generate_intervention_plan(anomalies)
```

## Resource Management Edge Cases

### Content Integration Failures
```prompt
Handle various content integration failure scenarios:
- API downtime
- Version mismatches
- Format incompatibilities
- Partial transfers
- Corrupted content
- Authentication failures

Example implementation:
class ContentIntegrationHandler:
    def safe_integrate(
        self,
        content: Dict,
        platform: str
    ) -> Dict:
        """Safely integrate content with fallbacks"""
        try:
            return await self._primary_integration(content, platform)
        except APIDownError:
            return await self._offline_fallback(content)
        except VersionMismatchError:
            return await self._version_adaptation(content)
        except FormatError:
            return await self._format_conversion(content)
        except CorruptionError:
            return await self._repair_and_retry(content)
```

### Resource Conflicts
```prompt
Implement handling for resource conflicts:
- Duplicate resources
- Conflicting metadata
- Version conflicts
- Access permission issues
- Storage constraints
- Update conflicts

Example structure:
class ResourceConflictResolver:
    def resolve_conflicts(
        self,
        resource: Dict,
        existing_resources: List[Dict]
    ) -> Dict:
        """Resolve various resource conflicts"""
        try:
            # Check for duplicates
            if self._is_duplicate(resource):
                return self._merge_resources(resource)
                
            # Handle metadata conflicts
            if self._has_metadata_conflict(resource):
                return self._resolve_metadata(resource)
                
            # Manage versions
            if self._has_version_conflict(resource):
                return self._handle_versioning(resource)
                
            # Check permissions
            if self._has_permission_conflict(resource):
                return self._adjust_permissions(resource)
                
            return resource
            
        except ConflictError:
            return self._create_conflict_report()
```

## Authentication Edge Cases

### Multi-Platform Authentication
```prompt
Handle complex authentication scenarios:
- Multiple platform logins
- Token expiration
- Failed SSO
- Partial authentication
- Cross-platform permissions
- Authentication chain breaks

Example implementation:
class MultiPlatformAuthManager:
    async def authenticate_platforms(
        self,
        credentials: Dict,
        platforms: List[str]
    ) -> Dict:
        """Manage authentication across platforms"""
        auth_results = {}
        
        for platform in platforms:
            try:
                auth_results[platform] = await self._authenticate(
                    platform,
                    credentials
                )
            except AuthenticationError as e:
                auth_results[platform] = await self._handle_auth_failure(
                    platform,
                    e
                )
            except TokenExpirationError:
                auth_results[platform] = await self._refresh_token(
                    platform,
                    credentials
                )
                
        return self._consolidate_auth_status(auth_results)
```

### Data Access Patterns
```prompt
Handle complex data access scenarios:
- Partial data access
- Temporary access loss
- Cross-platform data sync
- Access level changes
- Data privacy conflicts
- Access chain breaks

Example structure:
class DataAccessManager:
    async def manage_access(
        self,
        user_id: str,
        data_request: Dict
    ) -> Dict:
        """Manage complex data access patterns"""
        try:
            # Verify access levels
            access_levels = await self._verify_access(user_id)
            
            # Handle partial access
            if self._has_partial_access(access_levels):
                return await self._handle_partial_access(data_request)
                
            # Sync cross-platform
            if self._needs_sync(data_request):
                return await self._sync_access(data_request)
                
            # Check privacy requirements
            if self._has_privacy_constraints(data_request):
                return await self._apply_privacy_filters(data_request)
                
            return await self._fulfill_request(data_request)
            
        except AccessError:
            return await self._generate_access_report()
```

## System Recovery

### State Recovery
```prompt
Implement robust state recovery mechanisms:
- Session interruptions
- Partial saves
- Sync failures
- Data corruption
- State conflicts
- Recovery prioritization

Example implementation:
class StateRecoveryManager:
    async def recover_state(
        self,
        session_id: str,
        last_known_state: Dict
    ) -> Dict:
        """Recover system state after failures"""
        try:
            # Collect state fragments
            fragments = await self._gather_state_fragments(session_id)
            
            # Verify state integrity
            valid_fragments = self._verify_fragments(fragments)
            
            # Reconstruct state
            reconstructed_state = await self._reconstruct_state(valid_fragments)
            
            # Validate consistency
            if self._is_state_consistent(reconstructed_state):
                return reconstructed_state
            else:
                return await self._partial_recovery(valid_fragments)
                
        except RecoveryError:
            return await self._emergency_recovery(last_known_state)
```
