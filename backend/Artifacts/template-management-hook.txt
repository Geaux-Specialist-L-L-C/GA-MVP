import { useState, useEffect, useCallback } from 'react';
import { collection, query, where, onSnapshot, DocumentData } from 'firebase/firestore';
import { Template } from '../types/templates';

interface UseTemplatesResult {
  templates: Template[];
  isLoading: boolean;
  error: string | null;
  fetchTemplates: (type: string) => Promise<void>;
  saveTemplate: (template: Template) => Promise<void>;
  deleteTemplate: (templateId: string) => Promise<void>;
}

export const useTemplates = (
  firestore: FirebaseFirestore.Firestore
): UseTemplatesResult => {
  const [templates, setTemplates] = useState<Template[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Set up real-time listener for templates
  useEffect(() => {
    const templatesRef = collection(firestore, 'templates');
    
    const unsubscribe = onSnapshot(
      templatesRef,
      (snapshot) => {
        const templatesData: Template[] = [];
        snapshot.forEach((doc) => {
          templatesData.push({
            id: doc.id,
            ...doc.data() as Omit<Template, 'id'>
          });
        });
        setTemplates(templatesData);
        setIsLoading(false);
      },
      (err) => {
        setError(`Failed to fetch templates: ${err.message}`);
        setIsLoading(false);
      }
    );

    return () => unsubscribe();
  }, [firestore]);

  const fetchTemplates = useCallback(async (
    type: string
  ): Promise<void> => {
    setIsLoading(true);
    setError(null);

    try {
      const templatesRef = collection(firestore, 'templates');
      const q = query(templatesRef, where('type', '==', type));

      const unsubscribe = onSnapshot(
        q,
        (snapshot) => {
          const templatesData: Template[] = [];
          snapshot.forEach((doc) => {
            templatesData.push({
              id: doc.id,
              ...doc.data() as Omit<Template, 'id'>
            });
          });
          setTemplates(templatesData);
          setIsLoading(false);
        },
        (err) => {
          setError(`Failed to fetch ${type} templates: ${err.message}`);
          setIsLoading(false);
        }
      );

      return () => unsubscribe();
    } catch (err) {
      setError(`Failed to set up template listener: ${err.message}`);
      setIsLoading(false);
    }
  }, [firestore]);

  const saveTemplate = useCallback(async (
    template: Template
  ): Promise<void> => {
    try {
      const templateRef = doc(
        collection(firestore, 'templates'),
        template.id
      );

      await setDoc(templateRef, {
        ...template,
        updatedAt: new Date().toISOString()
      });
    } catch (err) {
      throw new Error(`Failed to save template: ${err.message}`);
    }
  }, [firestore]);

  const deleteTemplate = useCallback(async (
    templateId: string
  ): Promise<void> => {
    try {
      const templateRef = doc(
        collection(firestore, 'templates'),
        templateId
      );

      await deleteDoc(templateRef);
    } catch (err) {
      throw new Error(`Failed to delete template: ${err.message}`);
    }
  }, [firestore]);

  return {
    templates,
    isLoading,
    error,
    fetchTemplates,
    saveTemplate,
    deleteTemplate
  };
};

// Hook for managing template versioning
interface TemplateVersion extends Template {
  versionNumber: string;
  createdAt: string;
  createdBy: string;
}

interface UseTemplateVersioningResult {
  versions: TemplateVersion[];
  isLoading: boolean;
  error: string | null;
  createVersion: (template: Template) => Promise<void>;
  revertToVersion: (version: TemplateVersion) => Promise<void>;
}

export const useTemplateVersioning = (
  firestore: FirebaseFirestore.Firestore,
  templateId: string
): UseTemplateVersioningResult => {
  const [versions, setVersions] = useState<TemplateVersion[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const versionsRef = collection(
      firestore,
      'templates',
      templateId,
      'versions'
    );
    
    const q = query(
      versionsRef,
      orderBy('createdAt', 'desc')
    );

    const unsubscribe = onSnapshot(
      q,
      (snapshot) => {
        const versionsData: TemplateVersion[] = [];
        snapshot.forEach((doc) => {
          versionsData.push(doc.data() as TemplateVersion);
        });
        setVersions(versionsData);
        setIsLoading(false);
      },
      (err) => {
        setError(`Failed to fetch versions: ${err.message}`);
        setIsLoading(false);
      }
    );

    return () => unsubscribe();
  }, [firestore, templateId]);

  const createVersion = useCallback(async (
    template: Template
  ): Promise<void> => {
    try {
      const versionsRef = collection(
        firestore,
        'templates',
        templateId,
        'versions'
      );

      const versionNumber = `${versions.length + 1}.0.0`;
      
      await addDoc(versionsRef, {
        ...template,
        versionNumber,
        createdAt: new Date().toISOString(),
        createdBy: 'system', // TODO: Replace with actual user ID
        metadata: {
          ...template.metadata,
          versionNotes: ''
        }
      });
    } catch (err) {
      throw new Error(`Failed to create version: ${err.message}`);
    }
  }, [firestore, templateId, versions.length]);

  const revertToVersion = useCallback(async (
    version: TemplateVersion
  ): Promise<void> => {
    try {
      const batch = writeBatch(firestore);

      // Update main template document
      const templateRef = doc(firestore, 'templates', templateId);
      batch.update(templateRef, {
        ...version,
        updatedAt: new Date().toISOString(),
        metadata: {
          ...version.metadata,
          revertedFrom: version.versionNumber
        }
      });

      // Create new version record
      const versionsRef = collection(firestore, 'templates', templateId, 'versions');
      const newVersion = {
        ...version,
        versionNumber: `${versions.length + 1}.0.0`,
        createdAt: new Date().toISOString(),
        createdBy: 'system', // TODO: Replace with actual user ID
        metadata: {
          ...version.metadata,
          revertedFrom: version.versionNumber
        }
      };
      
      batch.set(doc(versionsRef), newVersion);

      await batch.commit();
    } catch (err) {
      throw new Error(`Failed to revert to version: ${err.message}`);
    }
  }, [firestore, templateId, versions.length]);

  return {
    versions,
    isLoading,
    error,
    createVersion,
    revertToVersion
  };
};

// Hook for template validation and agent interaction
interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  suggestions: string[];
}

interface UseTemplateValidationResult {
  validateTemplate: (template: Template) => Promise<ValidationResult>;
  isValidating: boolean;
  error: string | null;
}

export const useTemplateValidation = (
  agent: Agent
): UseTemplateValidationResult => {
  const [isValidating, setIsValidating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const validateTemplate = useCallback(async (
    template: Template
  ): Promise<ValidationResult> => {
    setIsValidating(true);
    setError(null);

    try {
      const validationTask = new Task({
        description: 'Validate template content and structure',
        parameters: {
          template,
          validationRules: [
            'standardsAlignment',
            'gradeAppropriate',
            'contentStructure',
            'accessibility'
          ]
        }
      });

      const result = await agent.execute(validationTask);

      return {
        isValid: result.isValid,
        errors: result.errors || [],
        warnings: result.warnings || [],
        suggestions: result.suggestions || []
      };
    } catch (err) {
      setError(`Validation failed: ${err.message}`);
      throw err;
    } finally {
      setIsValidating(false);
    }
  }, [agent]);

  return {
    validateTemplate,
    isValidating,
    error
  };
};

// Hook for template analytics
interface TemplateAnalytics {
  usageCount: number;
  averageCompletionTime: number;
  successRate: number;
  adaptationCount: number;
  popularAdaptations: string[];
}

interface UseTemplateAnalyticsResult {
  analytics: TemplateAnalytics | null;
  isLoading: boolean;
  error: string | null;
  refreshAnalytics: () => Promise<void>;
}

export const useTemplateAnalytics = (
  firestore: FirebaseFirestore.Firestore,
  templateId: string
): UseTemplateAnalyticsResult => {
  const [analytics, setAnalytics] = useState<TemplateAnalytics | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchAnalytics = useCallback(async (): Promise<void> => {
    try {
      const analyticsRef = doc(
        firestore,
        'templateAnalytics',
        templateId
      );

      const analyticsDoc = await getDoc(analyticsRef);
      
      if (analyticsDoc.exists()) {
        setAnalytics(analyticsDoc.data() as TemplateAnalytics);
      } else {
        setAnalytics({
          usageCount: 0,
          averageCompletionTime: 0,
          successRate: 0,
          adaptationCount: 0,
          popularAdaptations: []
        });
      }
    } catch (err) {
      setError(`Failed to fetch analytics: ${err.message}`);
    } finally {
      setIsLoading(false);
    }
  }, [firestore, templateId]);

  useEffect(() => {
    fetchAnalytics();
  }, [fetchAnalytics]);

  const refreshAnalytics = useCallback(async (): Promise<void> => {
    setIsLoading(true);
    await fetchAnalytics();
  }, [fetchAnalytics]);

  return {
    analytics,
    isLoading,
    error,
    refreshAnalytics
  };
};

// Utility function for template diff calculation
interface TemplateDiff {
  added: string[];
  removed: string[];
  modified: string[];
}

export const calculateTemplateDiff = (
  oldTemplate: Template,
  newTemplate: Template
): TemplateDiff => {
  const added: string[] = [];
  const removed: string[] = [];
  const modified: string[] = [];

  // Compare structure
  Object.keys(newTemplate.structure).forEach(key => {
    if (!oldTemplate.structure[key]) {
      added.push(`structure.${key}`);
    } else if (JSON.stringify(oldTemplate.structure[key]) !== 
               JSON.stringify(newTemplate.structure[key])) {
      modified.push(`structure.${key}`);
    }
  });

  Object.keys(oldTemplate.structure).forEach(key => {
    if (!newTemplate.structure[key]) {
      removed.push(`structure.${key}`);
    }
  });

  // Compare metadata
  Object.keys(newTemplate.metadata).forEach(key => {
    if (!oldTemplate.metadata[key]) {
      added.push(`metadata.${key}`);
    } else if (oldTemplate.metadata[key] !== newTemplate.metadata[key]) {
      modified.push(`metadata.${key}`);
    }
  });

  Object.keys(oldTemplate.metadata).forEach(key => {
    if (!newTemplate.metadata[key]) {
      removed.push(`metadata.${key}`);
    }
  });

  return {
    added,
    removed,
    modified
  };
};

export {
  useTemplates,
  useTemplateVersioning,
  useTemplateValidation,
  useTemplateAnalytics,
  calculateTemplateDiff
};