from typing import Dict, List, Optional, Set, Tuple
from dataclasses import dataclass
from datetime import datetime
import networkx as nx
from enum import Enum
import json

class CompetencyLevel(Enum):
    INTRODUCING = 1
    DEVELOPING = 2
    PROFICIENT = 3
    MASTERING = 4

@dataclass
class Competency:
    id: str
    name: str
    description: str
    level: CompetencyLevel
    prerequisites: List[str]
    indicators: List[str]
    standards: List[str]
    bloom_level: str

@dataclass
class LearningOutcome:
    id: str
    description: str
    competencies: List[str]
    assessment_criteria: List[str]
    evidence_types: List[str]

class CompetencyFramework:
    """Manages competency frameworks and mappings"""
    
    def __init__(self):
        self.competencies: Dict[str, Competency] = {}
        self.outcomes: Dict[str, LearningOutcome] = {}
        self.graph = nx.DiGraph()
        
    def add_competency(self, competency: Competency) -> None:
        """Add a competency to the framework"""
        self.competencies[competency.id] = competency
        self.graph.add_node(
            competency.id,
            name=competency.name,
            level=competency.level
        )
        
        # Add prerequisite relationships
        for prereq in competency.prerequisites:
            if prereq in self.competencies:
                self.graph.add_edge(prereq, competency.id)
                
    def add_outcome(self, outcome: LearningOutcome) -> None:
        """Add a learning outcome with competency mappings"""
        self.outcomes[outcome.id] = outcome
        
        # Add competency relationships
        for comp_id in outcome.competencies:
            if comp_id in self.competencies:
                self.graph.add_edge(
                    comp_id,
                    f"outcome_{outcome.id}",
                    type='demonstrates'
                )
                
    def validate_progression(self, sequence: List[str]) -> Tuple[bool, List[str]]:
        """Validate a learning progression sequence"""
        issues = []
        
        # Check prerequisites are met
        for i, comp_id in enumerate(sequence):
            if comp_id in self.competencies:
                comp = self.competencies[comp_id]
                covered = set(sequence[:i])
                missing = set(comp.prerequisites) - covered
                
                if missing:
                    issues.append(
                        f"Competency {comp.name} missing prerequisites: "
                        f"{', '.join(self.competencies[m].name for m in missing)}"
                    )
                    
        # Check level progression
        prev_level = None
        for comp_id in sequence:
            if comp_id in self.competencies:
                curr_level = self.competencies[comp_id].level
                if prev_level and curr_level.value < prev_level.value - 1:
                    issues.append(
                        f"Sharp competency level drop from {prev_level} to {curr_level}"
                    )
                prev_level = curr_level
                
        return len(issues) == 0, issues
        
    def get_prerequisites(self, competency_id: str) -> Set[str]:
        """Get all prerequisites for a competency"""
        if competency_id not in self.competencies:
            return set()
            
        return set(nx.ancestors(self.graph, competency_id))
        
    def get_dependent_outcomes(self, competency_id: str) -> List[str]:
        """Get outcomes that depend on a competency"""
        if competency_id not in self.competencies:
            return []
            
        return [
            node for node in nx.descendants(self.graph, competency_id)
            if node.startswith('outcome_')
        ]
        
    def export_framework(self) -> Dict:
        """Export the competency framework"""
        return {
            'competencies': [
                {
                    'id': comp.id,
                    'name': comp.name,
                    'description': comp.description,
                    'level': comp.level.name,
                    'prerequisites': comp.prerequisites,
                    'indicators': comp.indicators,
                    'standards': comp.standards,
                    'bloom_level': comp.bloom_level
                }
                for comp in self.competencies.values()
            ],
            'outcomes': [
                {
                    'id': outcome.id,
                    'description': outcome.description,
                    'competencies': outcome.competencies,
                    'assessment_criteria': outcome.assessment_criteria,
                    'evidence_types': outcome.evidence_types
                }
                for outcome in self.outcomes.values()
            ]
        }

class LearningAnalytics:
    """Manages learning analytics tracking and integration"""
    
    def __init__(self, competency_framework: CompetencyFramework):
        self.framework = competency_framework
        self.activity_logs: List[Dict] = []
        self.assessment_results: Dict[str, List[Dict]] = {}
        
    def log_activity(
        self,
        activity_id: str,
        activity_type: str,
        competency_id: str,
        metadata: Dict
    ) -> None:
        """Log a learning activity"""
        self.activity_logs.append({
            'timestamp': datetime.now().isoformat(),
            'activity_id': activity_id,
            'activity_type': activity_type,
            'competency_id': competency_id,
            'metadata': metadata
        })
        
    def record_assessment(
        self,
        student_id: str,
        assessment_id: str,
        competency_id: str,
        score: float,
        evidence: Dict
    ) -> None:
        """Record an assessment result"""
        if student_id not in self.assessment_results:
            self.assessment_results[student_id] = []
            
        self.assessment_results[student_id].append({
            'timestamp': datetime.now().isoformat(),
            'assessment_id': assessment_id,
            'competency_id': competency_id,
            'score': score,
            'evidence': evidence
        })
        
    def get_competency_progress(
        self,
        student_id: str,
        competency_id: str
    ) -> Dict:
        """Get progress on a specific competency"""
        if competency_id not in self.framework.competencies:
            raise ValueError(f"Unknown competency: {competency_id}")
            
        results = []
        if student_id in self.assessment_results:
            results = [
                r for r in self.assessment_results[student_id]
                if r['competency_id'] == competency_id
            ]
            
        activities = [
            log for log in self.activity_logs
            if log['competency_id'] == competency_id
        ]
        
        return {
            'competency': self.framework.competencies[competency_id],
            'assessment_results': results,
            'activities': activities,
            'mastery_level': self._calculate_mastery(results),
            'prerequisites_met': self._check_prerequisites(
                student_id,
                competency_id
            )
        }
        
    def generate_learning_path(
        self,
        student_id: str,
        target_competency: str
    ) -> List[str]:
        """Generate personalized learning path to target competency"""
        if target_competency not in self.framework.competencies:
            raise ValueError(f"Unknown competency: {target_competency}")
            
        # Get all prerequisites
        prerequisites = self.framework.get_prerequisites(target_competency)
        
        # Check current mastery levels
        mastery_levels = {
            comp_id: self._calculate_mastery(
                [r for r in self.assessment_results.get(student_id, [])
                 if r['competency_id'] == comp_id]
            )
            for comp_id in prerequisites | {target_competency}
        }
        
        # Sort by dependencies and mastery level
        path = []
        for comp_id in nx.topological_sort(
            self.framework.graph.subgraph(prerequisites | {target_competency})
        ):
            if mastery_levels.get(comp_id, 0) < 0.8:  # Mastery threshold
                path.append(comp_id)
                
        return path
        
    def _calculate_mastery(self, results: List[Dict]) -> float:
        """Calculate mastery level from assessment results"""
        if not results:
            return 0.0
            
        # Weight recent results more heavily
        weighted_sum = 0
        total_weight = 0
        
        for i, result in enumerate(sorted(
            results,
            key=lambda r: r['timestamp']
        )):
            weight = (i + 1) / len(results)  # Linear weight increase
            weighted_sum += result['score'] * weight
            total_weight += weight
            
        return weighted_sum / total_weight
        
    def _check_prerequisites(
        self,
        student_id: str,
        competency_id: str
    ) -> Dict[str, bool]:
        """Check prerequisite completion status"""
        prerequisites = self.framework.competencies[competency_id].prerequisites
        return {
            prereq: self._calculate_mastery([
                r for r in self.assessment_results.get(student_id, [])
                if r['competency_id'] == prereq
            ]) >= 0.8
            for prereq in prerequisites
        }
        
    def export_analytics(self, student_id: str) -> Dict:
        """Export analytics data for a student"""
        return {
            'student_id': student_id,
            'timestamp': datetime.now().isoformat(),
            'competency_progress': {
                comp_id: self.get_competency_progress(student_id, comp_id)
                for comp_id in self.framework.competencies
            },
            'assessment_history': self.assessment_results.get(student_id, []),
            'activity_logs': [
                log for log in self.activity_logs
                if log.get('metadata', {}).get('student_id') == student_id
            ]
        }

class CompetencyLMSIntegrator:
    """Integrates competency tracking with LMS platforms"""
    
    def __init__(
        self,
        framework: CompetencyFramework,
        analytics: LearningAnalytics
    ):
        self.framework = framework
        self.analytics = analytics
        
    def generate_lms_content(
        self,
        unit_plan: Dict,
        platform: str,
        settings: Dict
    ) -> Dict:
        """Generate LMS content with competency integration"""
        # Map unit objectives to competencies
        competency_mappings = self._map_objectives_to_competencies(
            unit_plan['objectives']
        )
        
        # Add competency metadata to activities
        activities = self._enhance_activities_with_competencies(
            unit_plan['activities'],
            competency_mappings
        )
        
        # Add analytics tracking
        tracking = self._generate_analytics_tracking(platform)
        
        # Create platform-specific content
        if platform == 'd2l':
            return self._generate_d2l_content(
                unit_plan,
                activities,
                tracking,
                settings
            )
        elif platform == 'canvas':
            return self._generate_canvas_content(
                unit_plan,
                activities,
                tracking,
                settings
            )
        else:
            return self._generate_generic_content(
                unit_plan,
                activities,
                tracking,
                settings
            )
            
    def _map_objectives_to_competencies(
        self,
        objectives: List[Dict]
    ) -> Dict[str, List[str]]:
        """Map learning objectives to competencies"""
        mappings = {}
        
        for objective in objectives:
            relevant_competencies = []
            obj_text = objective['description'].lower()
            
            for comp_id, comp in self.framework.competencies.items():
                # Check for keyword matches
                if any(
                    indicator.lower() in obj_text
                    for indicator in comp.indicators
                ):
                    relevant_competencies.append(comp_id)
                    
            if relevant_competencies:
                mappings[objective['id']] = relevant_competencies
                
        return mappings
        
    def _enhance_activities_with_competencies(
        self,
        activities: List[Dict],
        competency_mappings: Dict[str, List[str]]
    ) -> List[Dict]:
        """Add competency information to activities"""
        enhanced = []
        
        for activity in activities:
            activity_copy = activity.copy()
            
            # Find related competencies
            related_competencies = set()
            for obj_id, comp_ids in competency_mappings.items():
                if obj_id in activity.get('objectives', []):
                    related_competencies.update(comp_ids)
                    
            if related_competencies:
                activity_copy['competencies'] = list(related_competencies)
                activity_copy['competency_metadata'] = {
                    comp_id: {
                        'name': self.framework.competencies[comp_id].name,
                        'level': self.framework.competencies[comp_id].level.name,
                        'indicators': self.framework.competencies[comp_id].indicators
                    }
                    for comp_id in related_competencies
                }
                
            enhanced.append(activity_copy)
            
        return enhanced
        
    def _generate_analytics_tracking(self, platform: str) -> Dict:
        """Generate platform-specific analytics tracking code"""
        if platform == 'd2l':
            return {
                'tracking_type': 'valence_api',
                'events': ['view', 'submit', 'grade'],
                'data_points': ['timestamp', 'duration', 'score']
            }
        elif platform == 'canvas':
            return {
                'tracking_type': 'caliper',
                'events': ['NavigationEvent', 'AssessmentEvent', 'GradeEvent'],
                'data_points': ['eventTime', 'duration', 'result']
            }
        else:
            return {
                'tracking_type': 'xapi',
                'events': ['launched', 'completed', 'scored'],
                'data_points': ['timestamp', 'duration', 'score']
            }
            
    def _generate_d2l_content(
        self,
        unit_plan: Dict,
        activities: List[Dict],
        tracking: Dict,
        settings: Dict
    ) -> Dict:
        """Generate D2L-specific content with competency integration"""
        modules = []
        
        # Add competency overview module
        modules.append({
            'title': 'Competency Framework',
            'type': 'module',
            'materials': [
                {
                    'type': 'content',
                    'title': 'Learning Competencies',
                    'content': self._generate_competency_overview_html()
                }
            ]
        })
        
        # Add enhanced activities
        for activity in activities:
            if 'competencies' in activity:
                activity['custom_data'] = {
                    'competency_framework': {
                        'ids': activity['competencies'],
                        'tracking': tracking
                    }
                }
                
        # Add progress tracking
        if settings.get('includeAnalytics', True):
            # Add competency progress widget
            modules.append({
                'title': 'Progress Tracking',
                'type': 'module',
                'materials': [
                    {
                        'type': 'widget',
                        'title': 'Competency Progress',
                        'widget_type': 'progress_visualization',
                        'settings': {
                            'display_type': 'dashboard',
                            'show_prerequisites': True,
                            'show_mastery_levels': True
                        }
                    }
                ]
            })
            
        # Process activities with competency tracking
        activity_module = {
            'title': 'Learning Activities',
            'type': 'module',
            'materials': []
        }
        
        for activity in activities:
            material = {
                'type': 'activity',
                'title': activity['title'],
                'description': activity['description'],
                'tracking': tracking
            }
            
            if 'competencies' in activity:
                material['competency_data'] = {
                    'framework': 'custom',  # D2L-specific framework identifier
                    'competencies': [
                        {
                            'id': comp_id,
                            'name': self.framework.competencies[comp_id].name,
                            'level': self.framework.competencies[comp_id].level.name,
                            'indicators': self.framework.competencies[comp_id].indicators,
                            'tracking': {
                                'required_mastery': 0.8,
                                'assessment_methods': ['rubric', 'checklist'],
                                'evidence_types': ['submission', 'engagement']
                            }
                        }
                        for comp_id in activity['competencies']
                    ]
                }
                
            activity_module['materials'].append(material)
            
        modules.append(activity_module)
        
        return {
            'course': {
                'title': unit_plan['title'],
                'code': f"UNIT-{unit_plan.get('grade_level', 'NA')}",
                'competency_framework': {
                    'enabled': True,
                    'tracking_method': 'outcomes',
                    'display_progress': True
                },
                'modules': modules
            }
        }
        
    def _generate_canvas_content(
        self,
        unit_plan: Dict,
        activities: List[Dict],
        tracking: Dict,
        settings: Dict
    ) -> Dict:
        """Generate Canvas-specific content with competency integration"""
        modules = []
        
        # Add outcome alignment
        outcomes = []
        for comp_id, comp in self.framework.competencies.items():
            outcomes.append({
                'id': f"outcome_{comp_id}",
                'title': comp.name,
                'description': comp.description,
                'ratings': [
                    {
                        'description': f"Level {i+1}",
                        'points': (i+1) * 25
                    }
                    for i in range(4)
                ],
                'mastery_points': 75,  # Level 3 or higher
                'calculation_method': 'highest',
                'calculation_int': 5  # Consider last 5 assessments
            })
            
        # Add competency overview module
        modules.append({
            'name': 'Competency Framework',
            'position': 1,
            'items': [
                {
                    'type': 'Page',
                    'title': 'Learning Competencies',
                    'content': self._generate_competency_overview_html(),
                    'published': True
                }
            ]
        })
        
        # Process activities with outcome alignment
        activity_module = {
            'name': 'Learning Activities',
            'position': 2,
            'items': []
        }
        
        for activity in activities:
            item = {
                'type': 'Assignment',
                'title': activity['title'],
                'description': activity['description'],
                'submission_types': ['online_upload', 'online_text_entry'],
                'points_possible': 100,
                'published': True
            }
            
            if 'competencies' in activity:
                item['learning_outcome_alignments'] = [
                    {
                        'outcome_id': f"outcome_{comp_id}",
                        'mastery_score': 0.8
                    }
                    for comp_id in activity['competencies']
                ]
                
            activity_module['items'].append(item)
            
        modules.append(activity_module)
        
        # Add analytics if enabled
        if settings.get('includeAnalytics', True):
            modules.append({
                'name': 'Learning Progress',
                'position': 3,
                'items': [
                    {
                        'type': 'ExternalTool',
                        'title': 'Competency Dashboard',
                        'url': 'https://analytics.example.com/dashboard',
                        'external_data': {
                            'tracking': tracking,
                            'framework': self.framework.export_framework()
                        }
                    }
                ]
            })
            
        return {
            'course': {
                'name': unit_plan['title'],
                'course_code': f"UNIT-{unit_plan.get('grade_level', 'NA')}",
                'learning_outcomes': outcomes,
                'modules': modules,
                'settings': {
                    'enable_outcomes': True,
                    'enable_learning_mastery_gradebook': True
                }
            }
        }
        
    def _generate_generic_content(
        self,
        unit_plan: Dict,
        activities: List[Dict],
        tracking: Dict,
        settings: Dict
    ) -> Dict:
        """Generate generic LMS content with competency integration"""
        # Similar structure but with platform-agnostic elements
        return {
            'title': unit_plan['title'],
            'competency_framework': self.framework.export_framework(),
            'activities': activities,
            'tracking': tracking,
            'settings': settings
        }
        
    def _generate_competency_overview_html(self) -> str:
        """Generate HTML overview of competency framework"""
        return f"""
        <div class="competency-framework">
            <h2>Learning Competencies</h2>
            
            <div class="competency-levels">
                <h3>Competency Levels</h3>
                <ul>
                    {''.join(f'''
                        <li class="level-{level.value}">
                            <strong>{level.name}</strong>
                        </li>
                    ''' for level in CompetencyLevel)}
                </ul>
            </div>
            
            <div class="competency-list">
                {''.join(f'''
                    <div class="competency-item level-{comp.level.value}">
                        <h4>{comp.name}</h4>
                        <p>{comp.description}</p>
                        <div class="indicators">
                            <strong>Success Indicators:</strong>
                            <ul>
                                {''.join(f'<li>{indicator}</li>' for indicator in comp.indicators)}
                            </ul>
                        </div>
                        {self._generate_prerequisite_html(comp) if comp.prerequisites else ''}
                    </div>
                ''' for comp in self.framework.competencies.values())}
            </div>
        </div>
        """
        
    def _generate_prerequisite_html(self, competency: Competency) -> str:
        """Generate HTML for prerequisite display"""
        prereq_names = [
            self.framework.competencies[prereq_id].name
            for prereq_id in competency.prerequisites
            if prereq_id in self.framework.competencies
        ]
        
        if not prereq_names:
            return ''
            
        return f"""
        <div class="prerequisites">
            <strong>Prerequisites:</strong>
            <ul>
                {''.join(f'<li>{name}</li>' for name in prereq_names)}
            </ul>
        </div>
        """

# Example usage
if __name__ == "__main__":
    # Initialize framework and analytics
    framework = CompetencyFramework()
    analytics = LearningAnalytics(framework)
    
    # Add some competencies
    framework.add_competency(Competency(
        id="MATH.ALG.1",
        name="Basic Algebraic Operations",
        description="Perform basic algebraic operations with variables",
        level=CompetencyLevel.INTRODUCING,
        prerequisites=[],
        indicators=["Solve linear equations", "Combine like terms"],
        standards=["CCSS.Math.HSA.REI.A.1"],
        bloom_level="apply"
    ))
    
    framework.add_competency(Competency(
        id="MATH.ALG.2",
        name="Advanced Algebraic Manipulation",
        description="Manipulate complex algebraic expressions",
        level=CompetencyLevel.DEVELOPING,
        prerequisites=["MATH.ALG.1"],
        indicators=["Factor polynomials", "Solve quadratic equations"],
        standards=["CCSS.Math.HSA.SSE.A.2"],
        bloom_level="analyze"
    ))
    
    # Initialize integrator
    integrator = CompetencyLMSIntegrator(framework, analytics)
    
    # Sample unit plan
    unit_plan = {
        'title': "Algebraic Foundations",
        'grade_level': "9",
        'objectives': [
            {
                'id': "OBJ1",
                'description': "Students will solve linear equations"
            },
            {
                'id': "OBJ2",
                'description': "Students will factor polynomial expressions"
            }
        ],
        'activities': [
            {
                'title': "Linear Equations Practice",
                'description': "Practice solving various linear equations",
                'objectives': ["OBJ1"]
            },
            {
                'title': "Polynomial Factoring Lab",
                'description': "Interactive lab on factoring techniques",
                'objectives': ["OBJ2"]
            }
        ]
    }
    
    # Export settings
    settings = {
        'includeAnalytics': True,
        'includeCompetencies': True
    }
    
    # Generate content for different platforms
    d2l_content = integrator.generate_lms_content(unit_plan, 'd2l', settings)
    canvas_content = integrator.generate_lms_content(unit_plan, 'canvas', settings)
    
    print("Generated D2L content structure:")
    print(json.dumps(d2l_content, indent=2))
    
    print("\nGenerated Canvas content structure:")
    print(json.dumps(canvas_content, indent=2))
